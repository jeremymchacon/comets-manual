{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to the online dcumentation for COMETS - Computation Of Microbial Ecosystems in Time and Space. \n\n\nCOMETS is a software platform for performing computer simulations of spatially structured microbial communities. It is based on stoichiometric modeling of the genome-scale metabolic network of individual microbial species using dynamic flux balance analysis, and on a discrete approximation of diffusion. For more information, see \nHarcombe et al., Metabolic Resource Allocation in Individual Microbes Determines Ecosystem Interactions and Spatial Dynamics, Cell Reports, 2014\n.\n\n\nCOMETS is built and maintained by the \nDaniel Segre Lab\n at Boston University.\n\n\nCOMETS is open-source software. If you are interested in contributing to the development of COMETS and would like to obtain a copy of the code, please contact us: \ncomets@bu.edu",
            "title": "Home"
        },
        {
            "location": "/capabilities/",
            "text": "The core of COMETS is the simulation of the growth of microbial populations by maximizing an objective reaction, usually biomass production, in an iterative way. An initial amount of biomass of one or more species (defined by their metaboli models) is seeded in an environment containing a list of specified nutrients. In each iteration, both the amount of biomass and the environment are updated using FBA predictions. \n\n\nCapabilities in space\n\n\nCOMETS is capable of simulating microbial growth in a spatially structured environment. This is achieved by partitioning the simulation space (\"world\") in a \"grid\" of smaller spaces. Inside each space, growth is considered to be well-mixed. Both nutrients and biomass can then propagate to contiguous spaces as simulation proceeds. \n\n\n\n\n2D and 3D simulation \"worlds\"\n\n\n\n\nIn addition to well-mixed conditions, COMETS can simulate 2D and 3D spatially structured environments. This enables simulation of, for instance, growth of colonies on 2D surfaces such as a Petri dish, or 3D structures such as tumors, bacterial colonies in 3D matrix, etc.\n\n\n\n\nDiffusive and convective propagation of biomass in space\n\n\n\n\nIn simulations with spatial structure, different modes of biomass propagation are implemented. The diffusive mode simulates the propagation of free swimming motile bacteria, while the convective mode simulates the propagation of bacteria by mutual pushing. The two modes of propagation can be combined.\n\n\n\n\nSubstrate-dependent nutrient and biomass propagation\n\n\n\n\nThe diffusivity of nutrients as well as the propagation properties of the biomass depend on the substrate properties such as agar density, cell substrate friction coefficient etc. \n\n\n\n\nBoundary conditions\n\n\n\n\nTwo types of boundary conditions are implemented. Fixed value and fixed source or sink rate. \n\n\nBiological capabilities\n\n\nCOMETS features many interesting biological capabilities to refine and improve the predictions of stoichiometric models, as well as to simulate different types of biologically realistic conditions. \n\n\n\n\nLag-phases in microbial growth\n\n\n\n\nLag-phases are modelled as simulated growth activation of the colonies.\n\n\n\n\nContinuous (chemostat) and batch growth modes\n\n\n\n\nIn chemostat mode, the user controls the rate of replenishment of the nutrient. In batch mode, the user controls dilution and frequency.\n\n\n\n\nSimulation of multispecies communities\n\n\n\n\nSimulation of two or more species (up to hundreds) can be performed in both species overlapping or non-overlapping spatial distribution, or in well-mixed conditions. \n\n\n\n\nParsimonious dFBA\n\n\n\n\nUsually, any metabolic model has multiple optimal solutions. One way to choose among them is to assume that the cell will minimize the total flux through the metabolic network. To achieve this, parsimonious FBA first optimizes the objective function, e.g. growth. Then, it performs a second optimization by fixing growth at the previously obtained optimal level and minimizing the total flux through the network. \n\n\n\n\nCell death\n\n\n\n\nA simple model of cell death is implemented with each species assigned death rate.\n\n\n\n\nNeutral population drift\n\n\n\n\nThe presence of demographic noise can result in random variations in the abundance of different species in a simulation. This is especially useful in the batch-growth mode, where dilution bottlenecks can have a significant impact on growing populations. \n\n\n\n\nEvolutionary processes\n\n\n\n\nComets allows for evolutionary simulations, including random mutation and drift during simulations. Currently, the only mutations that are available are reaction deletions. \n\n\nComputational capabilities\n\n\nCOMETS software is implemented in the JAVA language. Therefore, it is highly portable and independent on the operative system. COMETS offers the following simulation capabilities. \n\n\n\n\nGraphical User Interface (GUI) \n\n\n\n\nIn addition to the command line, COMETS simulations can be run using a graphical user interface that includes visualization tools. \n\n\n\n\nParallelized dFBA \n\n\n\n\nRuns in multi-CPU systems as multi-threaded process for greater computational performance.\n\n\n\n\nMATLAB toolbox\n\n\n\n\nA toolbox in MATLAB for modifying the input files for COMETS in a programmatic way. \n\n\n\n\nPython toolbox\n\n\n\n\nA toolbox in Python for modifying the input files for COMETS in a programmatic way.",
            "title": "Capabilities"
        },
        {
            "location": "/capabilities/#capabilities-in-space",
            "text": "COMETS is capable of simulating microbial growth in a spatially structured environment. This is achieved by partitioning the simulation space (\"world\") in a \"grid\" of smaller spaces. Inside each space, growth is considered to be well-mixed. Both nutrients and biomass can then propagate to contiguous spaces as simulation proceeds.    2D and 3D simulation \"worlds\"   In addition to well-mixed conditions, COMETS can simulate 2D and 3D spatially structured environments. This enables simulation of, for instance, growth of colonies on 2D surfaces such as a Petri dish, or 3D structures such as tumors, bacterial colonies in 3D matrix, etc.   Diffusive and convective propagation of biomass in space   In simulations with spatial structure, different modes of biomass propagation are implemented. The diffusive mode simulates the propagation of free swimming motile bacteria, while the convective mode simulates the propagation of bacteria by mutual pushing. The two modes of propagation can be combined.   Substrate-dependent nutrient and biomass propagation   The diffusivity of nutrients as well as the propagation properties of the biomass depend on the substrate properties such as agar density, cell substrate friction coefficient etc.    Boundary conditions   Two types of boundary conditions are implemented. Fixed value and fixed source or sink rate.",
            "title": "Capabilities in space"
        },
        {
            "location": "/capabilities/#biological-capabilities",
            "text": "COMETS features many interesting biological capabilities to refine and improve the predictions of stoichiometric models, as well as to simulate different types of biologically realistic conditions.    Lag-phases in microbial growth   Lag-phases are modelled as simulated growth activation of the colonies.   Continuous (chemostat) and batch growth modes   In chemostat mode, the user controls the rate of replenishment of the nutrient. In batch mode, the user controls dilution and frequency.   Simulation of multispecies communities   Simulation of two or more species (up to hundreds) can be performed in both species overlapping or non-overlapping spatial distribution, or in well-mixed conditions.    Parsimonious dFBA   Usually, any metabolic model has multiple optimal solutions. One way to choose among them is to assume that the cell will minimize the total flux through the metabolic network. To achieve this, parsimonious FBA first optimizes the objective function, e.g. growth. Then, it performs a second optimization by fixing growth at the previously obtained optimal level and minimizing the total flux through the network.    Cell death   A simple model of cell death is implemented with each species assigned death rate.   Neutral population drift   The presence of demographic noise can result in random variations in the abundance of different species in a simulation. This is especially useful in the batch-growth mode, where dilution bottlenecks can have a significant impact on growing populations.    Evolutionary processes   Comets allows for evolutionary simulations, including random mutation and drift during simulations. Currently, the only mutations that are available are reaction deletions.",
            "title": "Biological capabilities"
        },
        {
            "location": "/capabilities/#computational-capabilities",
            "text": "COMETS software is implemented in the JAVA language. Therefore, it is highly portable and independent on the operative system. COMETS offers the following simulation capabilities.    Graphical User Interface (GUI)    In addition to the command line, COMETS simulations can be run using a graphical user interface that includes visualization tools.    Parallelized dFBA    Runs in multi-CPU systems as multi-threaded process for greater computational performance.   MATLAB toolbox   A toolbox in MATLAB for modifying the input files for COMETS in a programmatic way.    Python toolbox   A toolbox in Python for modifying the input files for COMETS in a programmatic way.",
            "title": "Computational capabilities"
        },
        {
            "location": "/installation/",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/python-module/getting_started/",
            "text": "The Comets Python Toolbox\n\n\nThe Comets python module is intended to offer a programatic, easy and intuitive interface to \nCOMETS\n. While it internally uses the same \nCOMETS\n Java engine as always, it replaces the legacy parameter files, simulation layouts or models, bash scripts and output files, by python objects in a single environment, which users deal with to perform simulations and analyze the results. \n\n\nAny comets simulation starts from a \nlayout\n and a set of \nparameters\n. The layout specifies the environment (media metabolites, refresh values, periodic dilutions) and the species present in it, that is, the \nmodels\n. The parameters specify many simulation characteristics, such as number of iterations, timestep, type of metabolite exchange or whether to record different output logs. Therefore, the two main types of objects are \nlayout\n and \nparams\n. These two are passed to the \ncomets\n class, which perform simulations and contain their output. \n\n\nIn this section, we will walk through the basic functionalities of \nCOMETS\n using the Python Toolbox, and more specific examples of usage will be provided in the next sections. \n\n\nPreparing a model for \nCOMETS\n\n\nThe class \nmodel\n is used to store the genome-scale metabolic models used in \nCOMETS\n simulations. Most frequently, we will first load a model using \nCOBRAPy\n. Then, we can pass it to the \nCOMETS\n \nmodel\n class, which allows us to change \nCOMETS\n-specific model parameters, such as initial population sizes.  \n\n\nimport cobra\nimport cobra.test\nimport cometspy as c\n\n# Load a textbook example model using the COBRAPy toolbox \ntest_model = cobra.test.create_test_model('textbook')\n\n# Use the above model to create a COMETS model\ntest_model = c.model(test_model)\n\n# Change comets specific parameters, e.g. the initial biomass of the model\n# Notre \ntest_model.initial_pop = [0, 0, 1e-7] \n\n\n\n\nUsing license file /home/djordje/gurobi.lic\nAcademic license - for non-commercial use only\n\n\n\nSetting \nCOMETS\n simulation parameters\n\n\nCOMETS\n simulation parameters are stored in the \nparams\n class, which contains just a \ndict\n object with the parameter names and values. If we initialize the class without arguments, it will contain the default parameter values (see \nhere\n). Once loaded, the parameter values can be visualized and modified as desired. \n\n\n# Create a parameters object with default values \nmy_params = c.params()\n\n# Change the value of a parameter, for example number of simulation cycles\nmy_params.set_param('maxCycles', 100)\n\n# Set some writeTotalBiomassLog parameter to True, in order to save the output\nmy_params.set_param('writeTotalBiomassLog', True)\n\n# See avaliable parameters and their values\nmy_params.show_params()\n\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n\n\n\n\n  \n\n    \n\n      \n\n      \nVALUE\n\n      \nUNITS\n\n    \n\n  \n\n  \n\n    \n\n      \nBiomassLogName\n\n      \nbiomass.txt\n\n      \n\n    \n\n    \n\n      \nBiomassLogRate\n\n      \n1\n\n      \ncycles\n\n    \n\n    \n\n      \nFluxLogName\n\n      \nflux_out\n\n      \n\n    \n\n    \n\n      \nFluxLogRate\n\n      \n5\n\n      \ncycles\n\n    \n\n    \n\n      \nMediaLogName\n\n      \nmedia_out\n\n      \n\n    \n\n    \n\n      \n...\n\n      \n...\n\n      \n...\n\n    \n\n    \n\n      \nwriteBiomassLog\n\n      \nFalse\n\n      \nlogical\n\n    \n\n    \n\n      \nwriteFluxLog\n\n      \nFalse\n\n      \nlogical\n\n    \n\n    \n\n      \nwriteMediaLog\n\n      \nFalse\n\n      \nlogical\n\n    \n\n    \n\n      \nwriteSpecificMediaLog\n\n      \nFalse\n\n      \nlogical\n\n    \n\n    \n\n      \nwriteTotalBiomassLog\n\n      \nTrue\n\n      \nlogical\n\n    \n\n  \n\n\n\n\n62 rows \u00d7 2 columns\n\n\n\n\n\nPreparing a \nCOMETS\n simulation layout\n\n\nThe layout class describes the characteristics of the environment, i.e. the \"world\", including which species (models) are in it. It can be instantiated in empty or using \nCOMETS\n models: \n\n\n\n\nIf instantiated without arguments (as \nmy_layout = c.layout()\n), an empty layout is created with all necessary fields that have to be populated.\n\n\nIf a layout is instantiated passing a \nmodel\n (or several models), it will generate a layout with all metabolites those models can exchange with the environment at zero concentration, plus metals and ions at unlimited concentration (default -1000).  \n\n\n\n\nTo examine the different parts of a Comets \nlayout\n, let\\'s first create one from the above loaded textbook model: \n\n\nmy_layout = c.layout(test_model)\n\n\n\n\nThe layout stores information about the species (\nmy_layout.models\n) and spatial structure (\nmy_layout.grid\n) in the environment. In this case, the model is only the textbook one, and the grid is the default one, which is \n1 \\times 1\n1 \\times 1\n i.e. only one cell.\n\n\nThe layout stores also information about the \nmedia\n as a pandas dataframe. In this case, no amount of any media component is present. \n\n\nmy_layout.media\n\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n\n\n\n\n  \n\n    \n\n      \n\n      \ndiff_c\n\n      \ng_refresh\n\n      \ng_static\n\n      \ng_static_val\n\n      \ninit_amount\n\n      \nmetabolite\n\n    \n\n  \n\n  \n\n    \n\n      \n0\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \nac_e\n\n    \n\n    \n\n      \n1\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \nacald_e\n\n    \n\n    \n\n      \n2\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \nakg_e\n\n    \n\n    \n\n      \n3\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \nco2_e\n\n    \n\n    \n\n      \n4\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \netoh_e\n\n    \n\n    \n\n      \n5\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \nfor_e\n\n    \n\n    \n\n      \n6\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \nfru_e\n\n    \n\n    \n\n      \n7\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \nfum_e\n\n    \n\n    \n\n      \n8\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \nglc__D_e\n\n    \n\n    \n\n      \n9\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \ngln__L_e\n\n    \n\n    \n\n      \n10\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \nglu__L_e\n\n    \n\n    \n\n      \n11\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \nh2o_e\n\n    \n\n    \n\n      \n12\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \nh_e\n\n    \n\n    \n\n      \n13\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \nlac__D_e\n\n    \n\n    \n\n      \n14\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \nmal__L_e\n\n    \n\n    \n\n      \n15\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \nnh4_e\n\n    \n\n    \n\n      \n16\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \no2_e\n\n    \n\n    \n\n      \n17\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \npi_e\n\n    \n\n    \n\n      \n18\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \npyr_e\n\n    \n\n    \n\n      \n19\n\n      \n0.000005\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \n0\n\n      \nsucc_e\n\n    \n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\nmetabolite\n\n\ninit_amount\n\n\ndiff_c\n\n\ng_static\n\n\ng_static_val\n\n\ng_refresh_val\n\n\n\n\n\n\n\n\n\n\nca2_e\n\n\n1000\n\n\nNaN\n\n\n1\n\n\n1000\n\n\n0\n\n\n\n\n\n\ncbl_e\n\n\n1000\n\n\nNaN\n\n\n1\n\n\n1000\n\n\n0\n\n\n\n\n\n\ncl_e\n\n\n1000\n\n\nNaN\n\n\n1\n\n\n1000\n\n\n0\n\n\n\n\n\n\n. . .\n\n\n. . .\n\n\n. . .\n\n\n. . .\n\n\n. . .\n\n\n. . .\n\n\n\n\n\n\n\n\nWhen initiated from models, the media compounds that can be in the environment are all those for which there is an exchange reaction in at least one of the models. The media, shown in the table above, is a \npandas\n dataframe where several pieces of information are stored:\n\n\n\n\ninit_amount\n is the initial amount to be added to each cell of the simulation grid (in mmol). \n\n\ndiff_c\n indicates whether the molecule has a diffusion constant different than the default one (stored in \nec_layout.global_diff\n)\n\n\ng_static\n indicates whether the component should remain at a static value, i.e. without change due to consumption and other effects of the simulation. This is useful for example, for setting some nutrients as unlimited. \n\n\ng_static_val\n indicates at which value shouold the nutrient remain static, if the previous coulmn value is 1. \n\n\ng_refresh_val\n indicates the amount of the metabolite that should be added after each simulation cycle to each cell of the grid. \n\n\n\n\nIn addition, we can set local \nstatic\n and \nrefresh\n values, specific to a cell of the simulation grid. \n\n\nWhen a media component is \nstatic\n, this means that its concentration is returned in each cycle to the set static value. This is used when we want a media component to remain virtually unlimited during a simulation. \n\n\nWhen a media component has a \nrefresh\n value, this means it will be replenished by adding the set amount at every simulation cycle. \n\n\nLocal refresh values are stored in a list, \nmy_layout.local_refresh\n, where each element of the list is itself a list with the form \n[ x  y  m1_r  m2_r  m3_r ... ]\n. The first two elements \nx\n and \ny\n represent the coordinates, and are followed by the refresh values for all metabolites, in the same order as in \nmedia\n.\n\n\nLocal static values are stored in a similar way. Each element of the \nmy_layout.local_static\n list is itself a list with the form \n[ x  y  m1_s  m1_s_v m2_s  m2_s_v ... ]\n. The difference here is that for each metabolite, there are two values, one defining whether the molecule is to be static at that coordinate (\nm1_s\n, \nm2_s\n, ... ) and another with the value at which it should be kept (\nm1_s_v\n, \nm2_s_v\n, ... ). \n\n\nNote that both \nlocal_refresh\n and \nlocal_static\n can be empty (the default), or contain only entries for the coordinates where there is at least one nonzero refresh or static value, respectively. \n\n\nFinally, the layout also contains information about the starting biomass of each model. This information is stored in the \ninitial_pop\n list. Each component of \ninitial_pop\n is itself a list with the format \n[x y biomass_1 biomass_2 ...]\nspecifying the amount of biomass of each model in each coordinate. \n\n\nRunning a \nCOMETS\n simulation\n\n\nThe \ncomets\n class uses a layout object and a parameters object to run simulations and store the output. Running a comets simulation is pretty straightforward. We firstly define the \ncomets\n object by passing it a \nlayout\n and a \nparams\n objects as arguments. Then, we \nrun()\n the simulation: \n\n\nmy_simulation = c.comets(my_layout, my_params)\nmy_simulation.run()\n\n\n\n\nRunning COMETS simulation ...\nDone!\n\n\n\nChecking simulation output and possible errors\n\n\nIn the background, this command invokes the \nCOMETS\n Java engine in a console, giving a standard output (stdout) and standard error (stderr) logs. Both can be acessed through the fields \nrun_outputs\n and \nrun_errors\n, respectively. \n\n\nprint(my_simulation.run_output)\n\n\n\n\n-script\nrunning script file: /home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/.current_script\nCurrent Java version: 11.0.7\nLoading layout file '/home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/.current_layout'...\nFound 1 model files!\nLoading '/home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/e_coli_core.cmd' ...\nLoading '/home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/e_coli_core.cmd' ...\nAcademic license - for non-commercial use only\nAcademic license - for non-commercial use only\nDone!\n Testing default parameters...\nDone!\nOptimizer status code = 5 (looks ok!)\nobjective solution = 0.8739215069684305\nConstructing world...\nDone!\nmedialist   ac_e    acald_e akg_e   co2_e   etoh_e  for_e   fru_e   fum_e   glc__D_e    gln__L_e    glu__L_e    h2o_e   h_e lac__D_e    mal__L_e    nh4_e   o2_e    pi_e    pyr_e   succ_e\nCycle 1\nTotal biomass:\nModel e_coli_core.cmd: 1.0E-7\nCycle 2\nTotal biomass:\nModel e_coli_core.cmd: 1.0E-7\n...\nTotal time = 0.312s\n\n\n\nprint(my_simulation.run_errors)\n\n\n\n\nSTDERR empty.\n\n\n\nAccessing the results of the simulation\n\n\nThe results of the successful simulation are stored in several fields in the \ncomets\n object, depending on whether the parameters \nwriteTotalBiomasslog\n,  \nwriteBiomassLog\n, \nwriteFluxLog\n and \nwriteMediaLog\n were set to \nTrue\n. \n\n\n\n\nThe field \ntotal_biomass\n  stores the total biomass (summed up over all coordinates) for each timepoint and species.\n\n\nThe field \nbiomass\n stores detailed biomass values for each timepoint, coordinate and species. \n\n\nThe field \nmedia\n stores the composition of the media at each timepoint.\n\n\nThe field \nfluxes\n stores the metabolic fluxes for each species, coordinate and timepoint. \n\n\n\n\nAdditionally, specific comets modes will have additional output fields; for instance, if we run an evolution simulation, the field \ngenotypes\n will store information about each species such as its ancestor and which mutation it suffered. \n\n\nAll of the output files ae \npandas\n dataframes which can be further analyzed or plotted using standard Python tools.  \n\n\nmy_simulation.total_biomass\n\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n\n\n\n\n  \n\n    \n\n      \n\n      \ncycle\n\n      \ne_coli_core\n\n    \n\n  \n\n  \n\n    \n\n      \n0\n\n      \n0.0\n\n      \n1.000000e-07\n\n    \n\n    \n\n      \n1\n\n      \n1.0\n\n      \n1.000000e-07\n\n    \n\n    \n\n      \n2\n\n      \n2.0\n\n      \n1.000000e-07\n\n    \n\n    \n\n      \n3\n\n      \n3.0\n\n      \n1.000000e-07\n\n    \n\n    \n\n      \n4\n\n      \n4.0\n\n      \n1.000000e-07\n\n    \n\n    \n\n      \n...\n\n      \n...\n\n      \n...\n\n    \n\n    \n\n      \n96\n\n      \n96.0\n\n      \n1.000000e-07\n\n    \n\n    \n\n      \n97\n\n      \n97.0\n\n      \n1.000000e-07\n\n    \n\n    \n\n      \n98\n\n      \n98.0\n\n      \n1.000000e-07\n\n    \n\n    \n\n      \n99\n\n      \n99.0\n\n      \n1.000000e-07\n\n    \n\n    \n\n      \n100\n\n      \n100.0\n\n      \n1.000000e-07\n\n    \n\n  \n\n\n\n\n101 rows \u00d7 2 columns",
            "title": "Getting started"
        },
        {
            "location": "/python-module/getting_started/#the-comets-python-toolbox",
            "text": "The Comets python module is intended to offer a programatic, easy and intuitive interface to  COMETS . While it internally uses the same  COMETS  Java engine as always, it replaces the legacy parameter files, simulation layouts or models, bash scripts and output files, by python objects in a single environment, which users deal with to perform simulations and analyze the results.   Any comets simulation starts from a  layout  and a set of  parameters . The layout specifies the environment (media metabolites, refresh values, periodic dilutions) and the species present in it, that is, the  models . The parameters specify many simulation characteristics, such as number of iterations, timestep, type of metabolite exchange or whether to record different output logs. Therefore, the two main types of objects are  layout  and  params . These two are passed to the  comets  class, which perform simulations and contain their output.   In this section, we will walk through the basic functionalities of  COMETS  using the Python Toolbox, and more specific examples of usage will be provided in the next sections.",
            "title": "The Comets Python Toolbox"
        },
        {
            "location": "/python-module/getting_started/#preparing-a-model-for-comets",
            "text": "The class  model  is used to store the genome-scale metabolic models used in  COMETS  simulations. Most frequently, we will first load a model using  COBRAPy . Then, we can pass it to the  COMETS   model  class, which allows us to change  COMETS -specific model parameters, such as initial population sizes.    import cobra\nimport cobra.test\nimport cometspy as c\n\n# Load a textbook example model using the COBRAPy toolbox \ntest_model = cobra.test.create_test_model('textbook')\n\n# Use the above model to create a COMETS model\ntest_model = c.model(test_model)\n\n# Change comets specific parameters, e.g. the initial biomass of the model\n# Notre \ntest_model.initial_pop = [0, 0, 1e-7]   Using license file /home/djordje/gurobi.lic\nAcademic license - for non-commercial use only",
            "title": "Preparing a model for COMETS"
        },
        {
            "location": "/python-module/getting_started/#setting-comets-simulation-parameters",
            "text": "COMETS  simulation parameters are stored in the  params  class, which contains just a  dict  object with the parameter names and values. If we initialize the class without arguments, it will contain the default parameter values (see  here ). Once loaded, the parameter values can be visualized and modified as desired.   # Create a parameters object with default values \nmy_params = c.params()\n\n# Change the value of a parameter, for example number of simulation cycles\nmy_params.set_param('maxCycles', 100)\n\n# Set some writeTotalBiomassLog parameter to True, in order to save the output\nmy_params.set_param('writeTotalBiomassLog', True)\n\n# See avaliable parameters and their values\nmy_params.show_params()   \n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }  \n   \n     \n       \n       VALUE \n       UNITS \n     \n   \n   \n     \n       BiomassLogName \n       biomass.txt \n       \n     \n     \n       BiomassLogRate \n       1 \n       cycles \n     \n     \n       FluxLogName \n       flux_out \n       \n     \n     \n       FluxLogRate \n       5 \n       cycles \n     \n     \n       MediaLogName \n       media_out \n       \n     \n     \n       ... \n       ... \n       ... \n     \n     \n       writeBiomassLog \n       False \n       logical \n     \n     \n       writeFluxLog \n       False \n       logical \n     \n     \n       writeMediaLog \n       False \n       logical \n     \n     \n       writeSpecificMediaLog \n       False \n       logical \n     \n     \n       writeTotalBiomassLog \n       True \n       logical \n     \n     62 rows \u00d7 2 columns",
            "title": "Setting COMETS simulation parameters"
        },
        {
            "location": "/python-module/getting_started/#preparing-a-comets-simulation-layout",
            "text": "The layout class describes the characteristics of the environment, i.e. the \"world\", including which species (models) are in it. It can be instantiated in empty or using  COMETS  models:    If instantiated without arguments (as  my_layout = c.layout() ), an empty layout is created with all necessary fields that have to be populated.  If a layout is instantiated passing a  model  (or several models), it will generate a layout with all metabolites those models can exchange with the environment at zero concentration, plus metals and ions at unlimited concentration (default -1000).     To examine the different parts of a Comets  layout , let\\'s first create one from the above loaded textbook model:   my_layout = c.layout(test_model)  The layout stores information about the species ( my_layout.models ) and spatial structure ( my_layout.grid ) in the environment. In this case, the model is only the textbook one, and the grid is the default one, which is  1 \\times 1 1 \\times 1  i.e. only one cell.  The layout stores also information about the  media  as a pandas dataframe. In this case, no amount of any media component is present.   my_layout.media   \n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }  \n   \n     \n       \n       diff_c \n       g_refresh \n       g_static \n       g_static_val \n       init_amount \n       metabolite \n     \n   \n   \n     \n       0 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       ac_e \n     \n     \n       1 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       acald_e \n     \n     \n       2 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       akg_e \n     \n     \n       3 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       co2_e \n     \n     \n       4 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       etoh_e \n     \n     \n       5 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       for_e \n     \n     \n       6 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       fru_e \n     \n     \n       7 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       fum_e \n     \n     \n       8 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       glc__D_e \n     \n     \n       9 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       gln__L_e \n     \n     \n       10 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       glu__L_e \n     \n     \n       11 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       h2o_e \n     \n     \n       12 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       h_e \n     \n     \n       13 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       lac__D_e \n     \n     \n       14 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       mal__L_e \n     \n     \n       15 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       nh4_e \n     \n     \n       16 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       o2_e \n     \n     \n       17 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       pi_e \n     \n     \n       18 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       pyr_e \n     \n     \n       19 \n       0.000005 \n       0 \n       0 \n       0 \n       0 \n       succ_e \n     \n         metabolite  init_amount  diff_c  g_static  g_static_val  g_refresh_val      ca2_e  1000  NaN  1  1000  0    cbl_e  1000  NaN  1  1000  0    cl_e  1000  NaN  1  1000  0    . . .  . . .  . . .  . . .  . . .  . . .     When initiated from models, the media compounds that can be in the environment are all those for which there is an exchange reaction in at least one of the models. The media, shown in the table above, is a  pandas  dataframe where several pieces of information are stored:   init_amount  is the initial amount to be added to each cell of the simulation grid (in mmol).   diff_c  indicates whether the molecule has a diffusion constant different than the default one (stored in  ec_layout.global_diff )  g_static  indicates whether the component should remain at a static value, i.e. without change due to consumption and other effects of the simulation. This is useful for example, for setting some nutrients as unlimited.   g_static_val  indicates at which value shouold the nutrient remain static, if the previous coulmn value is 1.   g_refresh_val  indicates the amount of the metabolite that should be added after each simulation cycle to each cell of the grid.    In addition, we can set local  static  and  refresh  values, specific to a cell of the simulation grid.   When a media component is  static , this means that its concentration is returned in each cycle to the set static value. This is used when we want a media component to remain virtually unlimited during a simulation.   When a media component has a  refresh  value, this means it will be replenished by adding the set amount at every simulation cycle.   Local refresh values are stored in a list,  my_layout.local_refresh , where each element of the list is itself a list with the form  [ x  y  m1_r  m2_r  m3_r ... ] . The first two elements  x  and  y  represent the coordinates, and are followed by the refresh values for all metabolites, in the same order as in  media .  Local static values are stored in a similar way. Each element of the  my_layout.local_static  list is itself a list with the form  [ x  y  m1_s  m1_s_v m2_s  m2_s_v ... ] . The difference here is that for each metabolite, there are two values, one defining whether the molecule is to be static at that coordinate ( m1_s ,  m2_s , ... ) and another with the value at which it should be kept ( m1_s_v ,  m2_s_v , ... ).   Note that both  local_refresh  and  local_static  can be empty (the default), or contain only entries for the coordinates where there is at least one nonzero refresh or static value, respectively.   Finally, the layout also contains information about the starting biomass of each model. This information is stored in the  initial_pop  list. Each component of  initial_pop  is itself a list with the format  [x y biomass_1 biomass_2 ...] specifying the amount of biomass of each model in each coordinate.",
            "title": "Preparing a COMETS simulation layout"
        },
        {
            "location": "/python-module/getting_started/#running-a-comets-simulation",
            "text": "The  comets  class uses a layout object and a parameters object to run simulations and store the output. Running a comets simulation is pretty straightforward. We firstly define the  comets  object by passing it a  layout  and a  params  objects as arguments. Then, we  run()  the simulation:   my_simulation = c.comets(my_layout, my_params)\nmy_simulation.run()  Running COMETS simulation ...\nDone!",
            "title": "Running a COMETS simulation"
        },
        {
            "location": "/python-module/getting_started/#checking-simulation-output-and-possible-errors",
            "text": "In the background, this command invokes the  COMETS  Java engine in a console, giving a standard output (stdout) and standard error (stderr) logs. Both can be acessed through the fields  run_outputs  and  run_errors , respectively.   print(my_simulation.run_output)  -script\nrunning script file: /home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/.current_script\nCurrent Java version: 11.0.7\nLoading layout file '/home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/.current_layout'...\nFound 1 model files!\nLoading '/home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/e_coli_core.cmd' ...\nLoading '/home/djordje/Dropbox/projects/comets_paper/Methods_Paper_Materials/COMETS_Examples/COMETS_getting_started/Python/e_coli_core.cmd' ...\nAcademic license - for non-commercial use only\nAcademic license - for non-commercial use only\nDone!\n Testing default parameters...\nDone!\nOptimizer status code = 5 (looks ok!)\nobjective solution = 0.8739215069684305\nConstructing world...\nDone!\nmedialist   ac_e    acald_e akg_e   co2_e   etoh_e  for_e   fru_e   fum_e   glc__D_e    gln__L_e    glu__L_e    h2o_e   h_e lac__D_e    mal__L_e    nh4_e   o2_e    pi_e    pyr_e   succ_e\nCycle 1\nTotal biomass:\nModel e_coli_core.cmd: 1.0E-7\nCycle 2\nTotal biomass:\nModel e_coli_core.cmd: 1.0E-7\n...\nTotal time = 0.312s  print(my_simulation.run_errors)  STDERR empty.",
            "title": "Checking simulation output and possible errors"
        },
        {
            "location": "/python-module/getting_started/#accessing-the-results-of-the-simulation",
            "text": "The results of the successful simulation are stored in several fields in the  comets  object, depending on whether the parameters  writeTotalBiomasslog ,   writeBiomassLog ,  writeFluxLog  and  writeMediaLog  were set to  True .    The field  total_biomass   stores the total biomass (summed up over all coordinates) for each timepoint and species.  The field  biomass  stores detailed biomass values for each timepoint, coordinate and species.   The field  media  stores the composition of the media at each timepoint.  The field  fluxes  stores the metabolic fluxes for each species, coordinate and timepoint.    Additionally, specific comets modes will have additional output fields; for instance, if we run an evolution simulation, the field  genotypes  will store information about each species such as its ancestor and which mutation it suffered.   All of the output files ae  pandas  dataframes which can be further analyzed or plotted using standard Python tools.    my_simulation.total_biomass   \n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }  \n   \n     \n       \n       cycle \n       e_coli_core \n     \n   \n   \n     \n       0 \n       0.0 \n       1.000000e-07 \n     \n     \n       1 \n       1.0 \n       1.000000e-07 \n     \n     \n       2 \n       2.0 \n       1.000000e-07 \n     \n     \n       3 \n       3.0 \n       1.000000e-07 \n     \n     \n       4 \n       4.0 \n       1.000000e-07 \n     \n     \n       ... \n       ... \n       ... \n     \n     \n       96 \n       96.0 \n       1.000000e-07 \n     \n     \n       97 \n       97.0 \n       1.000000e-07 \n     \n     \n       98 \n       98.0 \n       1.000000e-07 \n     \n     \n       99 \n       99.0 \n       1.000000e-07 \n     \n     \n       100 \n       100.0 \n       1.000000e-07 \n     \n     101 rows \u00d7 2 columns",
            "title": "Accessing the results of the simulation"
        },
        {
            "location": "/python-module/test_tube/",
            "text": "Growth in a test tube\n\n\nThis simple example illustrates the basic workflow of COMETS, including how to build the simulation layout, to specify parameters, load the model and plot the data once the simulation is finished.\n\n\nThe core of the COMETS methodology is the Dynamic Flux Balance Analysis algorithm (Madahevan et al 2002). One of the first successful simulations of the time dynamics of bacterial metabolism was the classical study of \nEscherichia coli\n batch culture by Varma and Palsson (1994). Here, we reproduce one of the results in that study, the anaerobic fermentation in minimal media with glucose as the only carbon source.\n\n\nWe will simulate a test tube by setting a well-mixed virtual container with \n1cm3\n1cm3\n of media, which we will inoculate with \n5\\times10^{\u22126}\n5\\times10^{\u22126}\n grams of E. coli biomass. We will set the initial composition of the substrate to 11mM of glucose and unlimited amounts of ammonia and phosphate. For the nutrient uptake, we will use standard Michaelis-Menten kinetics, using the experimentally measured Monod parameter for anaerobic uptake of glucose by E. coli.\n\n\nFor this simple example, we use the rudimentary \"core\" model of E. coli (Orth et al. 2009), which can be downloaded from http://bigg.ucsd.edu/models/e_coli_core or loaded, as we do here, using a function built in CobraPy. This model represents an E. coli metabolism simplified to its core functions (glycolysis, tricarboxylic cycle, pentose phosphate shunt, etc).\n\n\nLoading the COMETS Python Toolbox\n\n\nWe first import the COMETS Python toolbox, which will also load all the dependencies, such as CobraPy or pandas.\n\n\nimport cometspy as c\nimport cobra.test\nimport matplotlib.pyplot as plt\n\n\n\n\nCreating a test tube\n\n\nWe are now ready to create a \"layout\" for our simulation. By instantiating the class layout without arguments, we will create the default simulation layout, represents an empty, well mixed space (called \"cell\") with volume 1cm^3. We can then modify this layout according to our needs, in this case adding the media composition in the desired concentration.\n\n\n# Create empty 1x1 layout\ntest_tube = c.layout()\n\n# Add 11mM glucose and remove o2\ntest_tube.set_specific_metabolite('glc__D_e', 0.011)\ntest_tube.set_specific_metabolite('o2_e', 0)\n\n# Add the rest of nutrients unlimited (ammonia, phosphate, water and protons)\ntest_tube.set_specific_metabolite('nh4_e',1000);\ntest_tube.set_specific_metabolite('pi_e',1000);\ntest_tube.set_specific_metabolite('h2o_e',1000);\ntest_tube.set_specific_metabolite('h_e',1000);\n\n\n\n\nbuilding empty layout model\nmodels will need to be added with layout.add_model()\nWarning: The added metabolite (glc__D_e) is notable to be taken up by any of the current models\nWarning: The added metabolite (o2_e) is notable to be taken up by any of the current models\nWarning: The added metabolite (nh4_e) is notable to be taken up by any of the current models\nWarning: The added metabolite (pi_e) is notable to be taken up by any of the current models\nWarning: The added metabolite (h2o_e) is notable to be taken up by any of the current models\nWarning: The added metabolite (h_e) is notable to be taken up by any of the current models\n\n\n\nLoading a model\n\n\nNext, we have to load the model and add it to the layout (or \"inoculate it in our test tube\").\n\n\nWe will instantiate the comets model class using a loaded CobraPy model as input.\n\n\nNote that we remove the bounds on glucose import, which will be set dynamically by COMETS during the simulation according to the dynamically changing external glucose concentration. We will set the initial biomass of our model at \n10^{-6}\n10^{-6}\n grams.\n\n\n# create the model using CobraPy functionality\ne_coli_cobra = cobra.test.create_test_model('textbook')\n\n# use the loaded model to build a comets model\ne_coli = c.model(e_coli_cobra)\n\n# remove the bounds from glucose import (will be set dynamically by COMETS)\ne_coli.change_bounds('EX_glc__D_e', -1000, 1000)\n\n# set the model's initial biomass\ne_coli.initial_pop = [0, 0, 5e-6]\n\n# add it to the test_tube\ntest_tube.add_model(e_coli)\n\n\n\n\nUsing license file /home/djordje/gurobi.lic\nAcademic license - for non-commercial use only\n\n\n\nSetting the simulation parameters\n\n\nWe next instantiate the params class, which generates a set of parameters for the COMETS simulation with the [TODO LINK TO DEF VALS] default values for all of them. All of the parameters are contained in the all_params field which is a Python dict object, making it easy to change the value of the desired parameters.\n\n\n# Set the parameters that are different from the default\nsim_params = c.params()\n\n\n\n\nsim_params.set_param('defaultVmax', 18.5)\nsim_params.set_param('defaultKm', 0.000015)\nsim_params.set_param('maxCycles', 1000)\nsim_params.set_param('timeStep', 0.01)\nsim_params.set_param('spaceWidth', 1)\nsim_params.set_param('maxSpaceBiomass', 10)\nsim_params.set_param('minSpaceBiomass', 1e-11)\nsim_params.set_param('writeMediaLog', True)\n\n\n\n\nRunning the simulation\n\n\nWith all set up, we can now instantiate the comets class by passing the layout (containing the model) and the params objects we just created.\n\n\nexperiment = c.comets(test_tube, sim_params)\n\n\n\n\nFinally, we can run the simulation as:\n\n\nexperiment.run()\n\n\n\n\nRunning COMETS simulation ...\nDone!\n\n\n\nAnalyzing the results\n\n\nThe results of our simulation are stored in several pandas data frames contained in the comets object that we just simulated. The growth of the simulated model can be seen by plotting the total_biomass field.\n\n\nax = experiment.total_biomass.plot(x = 'cycle')\nax.set_ylabel(\"Biomass (gr.)\")\n\n\n\n\n\n\nSimilarly, we can plot composition of the media. In this case, we will limit the plot to those components that are not added to the layout in unlimited amounts (\u201cstatic\u201d compounds, e.g. ammonia, phosphate, water, etc in this simulation). In this case, we do this by limiting the plot to compounds with concentration lower than 900mM.\n\n\nmedia = experiment.media.copy()\nmedia = media[media.conc_mmol<900]\n\nfig, ax = plt.subplots()\nmedia.groupby('metabolite').plot(x='cycle', ax =ax, y='conc_mmol')\nax.legend(('acetate','ethanol', 'formate', 'glucose'))\nax.set_ylabel(\"Concentration (mmol)\")",
            "title": "Growth in a test tube"
        },
        {
            "location": "/python-module/test_tube/#growth-in-a-test-tube",
            "text": "This simple example illustrates the basic workflow of COMETS, including how to build the simulation layout, to specify parameters, load the model and plot the data once the simulation is finished.  The core of the COMETS methodology is the Dynamic Flux Balance Analysis algorithm (Madahevan et al 2002). One of the first successful simulations of the time dynamics of bacterial metabolism was the classical study of  Escherichia coli  batch culture by Varma and Palsson (1994). Here, we reproduce one of the results in that study, the anaerobic fermentation in minimal media with glucose as the only carbon source.  We will simulate a test tube by setting a well-mixed virtual container with  1cm3 1cm3  of media, which we will inoculate with  5\\times10^{\u22126} 5\\times10^{\u22126}  grams of E. coli biomass. We will set the initial composition of the substrate to 11mM of glucose and unlimited amounts of ammonia and phosphate. For the nutrient uptake, we will use standard Michaelis-Menten kinetics, using the experimentally measured Monod parameter for anaerobic uptake of glucose by E. coli.  For this simple example, we use the rudimentary \"core\" model of E. coli (Orth et al. 2009), which can be downloaded from http://bigg.ucsd.edu/models/e_coli_core or loaded, as we do here, using a function built in CobraPy. This model represents an E. coli metabolism simplified to its core functions (glycolysis, tricarboxylic cycle, pentose phosphate shunt, etc).",
            "title": "Growth in a test tube"
        },
        {
            "location": "/python-module/test_tube/#loading-the-comets-python-toolbox",
            "text": "We first import the COMETS Python toolbox, which will also load all the dependencies, such as CobraPy or pandas.  import cometspy as c\nimport cobra.test\nimport matplotlib.pyplot as plt",
            "title": "Loading the COMETS Python Toolbox"
        },
        {
            "location": "/python-module/test_tube/#creating-a-test-tube",
            "text": "We are now ready to create a \"layout\" for our simulation. By instantiating the class layout without arguments, we will create the default simulation layout, represents an empty, well mixed space (called \"cell\") with volume 1cm^3. We can then modify this layout according to our needs, in this case adding the media composition in the desired concentration.  # Create empty 1x1 layout\ntest_tube = c.layout()\n\n# Add 11mM glucose and remove o2\ntest_tube.set_specific_metabolite('glc__D_e', 0.011)\ntest_tube.set_specific_metabolite('o2_e', 0)\n\n# Add the rest of nutrients unlimited (ammonia, phosphate, water and protons)\ntest_tube.set_specific_metabolite('nh4_e',1000);\ntest_tube.set_specific_metabolite('pi_e',1000);\ntest_tube.set_specific_metabolite('h2o_e',1000);\ntest_tube.set_specific_metabolite('h_e',1000);  building empty layout model\nmodels will need to be added with layout.add_model()\nWarning: The added metabolite (glc__D_e) is notable to be taken up by any of the current models\nWarning: The added metabolite (o2_e) is notable to be taken up by any of the current models\nWarning: The added metabolite (nh4_e) is notable to be taken up by any of the current models\nWarning: The added metabolite (pi_e) is notable to be taken up by any of the current models\nWarning: The added metabolite (h2o_e) is notable to be taken up by any of the current models\nWarning: The added metabolite (h_e) is notable to be taken up by any of the current models",
            "title": "Creating a test tube"
        },
        {
            "location": "/python-module/test_tube/#loading-a-model",
            "text": "Next, we have to load the model and add it to the layout (or \"inoculate it in our test tube\").  We will instantiate the comets model class using a loaded CobraPy model as input.  Note that we remove the bounds on glucose import, which will be set dynamically by COMETS during the simulation according to the dynamically changing external glucose concentration. We will set the initial biomass of our model at  10^{-6} 10^{-6}  grams.  # create the model using CobraPy functionality\ne_coli_cobra = cobra.test.create_test_model('textbook')\n\n# use the loaded model to build a comets model\ne_coli = c.model(e_coli_cobra)\n\n# remove the bounds from glucose import (will be set dynamically by COMETS)\ne_coli.change_bounds('EX_glc__D_e', -1000, 1000)\n\n# set the model's initial biomass\ne_coli.initial_pop = [0, 0, 5e-6]\n\n# add it to the test_tube\ntest_tube.add_model(e_coli)  Using license file /home/djordje/gurobi.lic\nAcademic license - for non-commercial use only",
            "title": "Loading a model"
        },
        {
            "location": "/python-module/test_tube/#setting-the-simulation-parameters",
            "text": "We next instantiate the params class, which generates a set of parameters for the COMETS simulation with the [TODO LINK TO DEF VALS] default values for all of them. All of the parameters are contained in the all_params field which is a Python dict object, making it easy to change the value of the desired parameters.  # Set the parameters that are different from the default\nsim_params = c.params()  sim_params.set_param('defaultVmax', 18.5)\nsim_params.set_param('defaultKm', 0.000015)\nsim_params.set_param('maxCycles', 1000)\nsim_params.set_param('timeStep', 0.01)\nsim_params.set_param('spaceWidth', 1)\nsim_params.set_param('maxSpaceBiomass', 10)\nsim_params.set_param('minSpaceBiomass', 1e-11)\nsim_params.set_param('writeMediaLog', True)",
            "title": "Setting the simulation parameters"
        },
        {
            "location": "/python-module/test_tube/#running-the-simulation",
            "text": "With all set up, we can now instantiate the comets class by passing the layout (containing the model) and the params objects we just created.  experiment = c.comets(test_tube, sim_params)  Finally, we can run the simulation as:  experiment.run()  Running COMETS simulation ...\nDone!",
            "title": "Running the simulation"
        },
        {
            "location": "/python-module/test_tube/#analyzing-the-results",
            "text": "The results of our simulation are stored in several pandas data frames contained in the comets object that we just simulated. The growth of the simulated model can be seen by plotting the total_biomass field.  ax = experiment.total_biomass.plot(x = 'cycle')\nax.set_ylabel(\"Biomass (gr.)\")   Similarly, we can plot composition of the media. In this case, we will limit the plot to those components that are not added to the layout in unlimited amounts (\u201cstatic\u201d compounds, e.g. ammonia, phosphate, water, etc in this simulation). In this case, we do this by limiting the plot to compounds with concentration lower than 900mM.  media = experiment.media.copy()\nmedia = media[media.conc_mmol<900]\n\nfig, ax = plt.subplots()\nmedia.groupby('metabolite').plot(x='cycle', ax =ax, y='conc_mmol')\nax.legend(('acetate','ethanol', 'formate', 'glucose'))\nax.set_ylabel(\"Concentration (mmol)\")",
            "title": "Analyzing the results"
        },
        {
            "location": "/python-module/competition_assay/",
            "text": "Competition assay and competitive exclusion in serial transfers\n\n\nCompetition experiments are frequently performed in the laboratory to assay, for example, the fitness of a mutant in competition to the wild-type. Here, we simulate one such experiemnt involving E. coli and a nonessential but deleterious mutation involving the deletion of the triose phosphate isomerase reaction from glycolisis. \n\n\nLoad models and create a mutant\n\n\nWe first load our \nE. coli\n \"core\" model and create the mutant in triose phosphate isomerase by setting both upper and lower bounds to zero. We will add both models to our \ntest_tube\n layout. \n\n\n# Start by loading required packages, including the COMETS toolbox\nimport cometspy as c\nimport cobra.test\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# load the models and perform the mutation\nwt = c.model(cobra.test.create_test_model(\"ecoli\"))\nwt.id = 'wt'\nmut = c.model(cobra.test.create_test_model(\"ecoli\"))\nmut.change_bounds('TPI', 0,0)\nmut.id = 'TPI_KO'\n\n# set its initial biomass, 5e-6 gr at coordinate [0,0]\nwt.initial_pop = [0, 0, 5e-8]\nmut.initial_pop = [0, 0, 5e-8]\n\n\n\n\nUsing license file /home/djordje/gurobi.lic\nAcademic license - for non-commercial use only\n\n\n\nCreate layout, add models and set up media composition\n\n\nWe create an empty layout (\"test_tube\") and set the initial nutrient supply.\n\n\n# create an empty layout\ntest_tube = c.layout()\n\n# add the models to the test tube\ntest_tube.add_model(wt)\ntest_tube.add_model(mut)\n\n\n\n\nbuilding empty layout model\nmodels will need to be added with layout.add_model()\n\n\n\nSet the media composition by adding glucose and the inorganic nutrients required for this model (ammonia, phosphate) and oxygen. These inorganic nutrients will be considered as \"static\" by the simulation, with a value of 1000 that never depletes. Considering metabolites as \"static\" is the way COMETS has to simulate an unlimited supply of metabolites.\n\n\n# Add glucose to the media \ntest_tube.set_specific_metabolite('glc__D_e', 0.01)\n\n# Add typical trace metabolites and oxygen coli as static\ntrace_metabolites = ['ca2_e', 'cl_e', 'cobalt2_e', 'cu2_e', 'fe2_e', 'fe3_e', 'h_e', 'k_e', 'h2o_e', 'mg2_e',\n                     'mn2_e', 'mobd_e', 'na1_e', 'ni2_e', 'nh4_e', 'o2_e', 'pi_e', 'so4_e', 'zn2_e']\n\nfor i in trace_metabolites:\n    test_tube.set_specific_metabolite(i, 1000)\n    test_tube.set_specific_static(i, 1000)\n\n\n\n\nSet up simulation parameters\n\n\nWe next create a parameters object and modify needed parameters - in this case only the number of cycles the simulation runs.  \n\n\ncomp_params = c.params()\ncomp_params.set_param('maxCycles', 240)\n\n\n\n\nRun the simulation\n\n\nFinally, we create the comets object using the above created layout and parameters, and run the competition assay. \n\n\ncomp_assay = c.comets(test_tube, comp_params)\ncomp_assay.run()\n\n\n\n\nRunning COMETS simulation ...\nDone!\n\n\n\nWe now plot the biomasses of these two genotypes in coculture. \n\n\nbiomass = comp_assay.total_biomass\nbiomass['t'] = biomass['cycle'] * comp_assay.parameters.all_params['timeStep']\n\nmyplot = biomass.drop(columns=['cycle']).plot(x = 't')\nmyplot.set_ylabel(\"Biomass (gr.)\")\n\n\n\n\n\n\nWe can quantitatively analyze the results. For example, we can compute the competitive fitness of the mutant respect to the wild-type as the ratio of the biomass increase of the mutant divided by that of the wild-type: \n\n\ncfit = (biomass.loc[biomass['t'] == 24, 'TPI_KO'].iloc[0]/biomass.loc[biomass['t'] == 0, 'TPI_KO'].iloc[0])/(biomass.loc[biomass['t'] == 24, 'wt'].iloc[0]/biomass.loc[biomass['t'] == 0, 'wt'].iloc[0])\ncfit\n\n\n\n\n0.39378816074777145\n\n\n\nSimulating serial transfers\n\n\nUsing \nCOMETS\n we can also simulate a serial tranfer competition between these two mutants. We will just modify the parameters, increasing the total simulation time and including batch transfers of 1% every 24h, but we will use the same \ntest_tube\n layout as before. \n\n\nserial_params = c.params()\nserial_params.set_param('maxCycles', 240*25) # simulate 4 serial transfers of 24h each\nserial_params.set_param('batchDilution', True)\nserial_params.set_param('dilFactor', 0.01)\nserial_params.set_param('dilTime', 24)\n\n\n\n\nWe run the simulation \n\n\nserial_expt = c.comets(test_tube, serial_params)\nserial_expt.JAVA_CLASSPATH = comp_assay.JAVA_CLASSPATH\nserial_expt.run()\n\n\n\n\nRunning COMETS simulation ...\nDone!\n\n\n\nNow plot the biomass of the two species during the experiment \n\n\nbiomass = serial_expt.total_biomass\nbiomass['transfer'] = biomass['cycle'] * comp_assay.parameters.all_params['timeStep']/24\n\nmyplot = biomass.drop(columns=['cycle']).plot(x = 'transfer')\nmyplot.set_ylabel(\"Biomass (gr.)\")",
            "title": "Competition assay"
        },
        {
            "location": "/python-module/competition_assay/#competition-assay-and-competitive-exclusion-in-serial-transfers",
            "text": "Competition experiments are frequently performed in the laboratory to assay, for example, the fitness of a mutant in competition to the wild-type. Here, we simulate one such experiemnt involving E. coli and a nonessential but deleterious mutation involving the deletion of the triose phosphate isomerase reaction from glycolisis.",
            "title": "Competition assay and competitive exclusion in serial transfers"
        },
        {
            "location": "/python-module/competition_assay/#load-models-and-create-a-mutant",
            "text": "We first load our  E. coli  \"core\" model and create the mutant in triose phosphate isomerase by setting both upper and lower bounds to zero. We will add both models to our  test_tube  layout.   # Start by loading required packages, including the COMETS toolbox\nimport cometspy as c\nimport cobra.test\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# load the models and perform the mutation\nwt = c.model(cobra.test.create_test_model(\"ecoli\"))\nwt.id = 'wt'\nmut = c.model(cobra.test.create_test_model(\"ecoli\"))\nmut.change_bounds('TPI', 0,0)\nmut.id = 'TPI_KO'\n\n# set its initial biomass, 5e-6 gr at coordinate [0,0]\nwt.initial_pop = [0, 0, 5e-8]\nmut.initial_pop = [0, 0, 5e-8]  Using license file /home/djordje/gurobi.lic\nAcademic license - for non-commercial use only",
            "title": "Load models and create a mutant"
        },
        {
            "location": "/python-module/competition_assay/#create-layout-add-models-and-set-up-media-composition",
            "text": "We create an empty layout (\"test_tube\") and set the initial nutrient supply.  # create an empty layout\ntest_tube = c.layout()\n\n# add the models to the test tube\ntest_tube.add_model(wt)\ntest_tube.add_model(mut)  building empty layout model\nmodels will need to be added with layout.add_model()  Set the media composition by adding glucose and the inorganic nutrients required for this model (ammonia, phosphate) and oxygen. These inorganic nutrients will be considered as \"static\" by the simulation, with a value of 1000 that never depletes. Considering metabolites as \"static\" is the way COMETS has to simulate an unlimited supply of metabolites.  # Add glucose to the media \ntest_tube.set_specific_metabolite('glc__D_e', 0.01)\n\n# Add typical trace metabolites and oxygen coli as static\ntrace_metabolites = ['ca2_e', 'cl_e', 'cobalt2_e', 'cu2_e', 'fe2_e', 'fe3_e', 'h_e', 'k_e', 'h2o_e', 'mg2_e',\n                     'mn2_e', 'mobd_e', 'na1_e', 'ni2_e', 'nh4_e', 'o2_e', 'pi_e', 'so4_e', 'zn2_e']\n\nfor i in trace_metabolites:\n    test_tube.set_specific_metabolite(i, 1000)\n    test_tube.set_specific_static(i, 1000)",
            "title": "Create layout, add models and set up media composition"
        },
        {
            "location": "/python-module/competition_assay/#set-up-simulation-parameters",
            "text": "We next create a parameters object and modify needed parameters - in this case only the number of cycles the simulation runs.    comp_params = c.params()\ncomp_params.set_param('maxCycles', 240)",
            "title": "Set up simulation parameters"
        },
        {
            "location": "/python-module/competition_assay/#run-the-simulation",
            "text": "Finally, we create the comets object using the above created layout and parameters, and run the competition assay.   comp_assay = c.comets(test_tube, comp_params)\ncomp_assay.run()  Running COMETS simulation ...\nDone!  We now plot the biomasses of these two genotypes in coculture.   biomass = comp_assay.total_biomass\nbiomass['t'] = biomass['cycle'] * comp_assay.parameters.all_params['timeStep']\n\nmyplot = biomass.drop(columns=['cycle']).plot(x = 't')\nmyplot.set_ylabel(\"Biomass (gr.)\")   We can quantitatively analyze the results. For example, we can compute the competitive fitness of the mutant respect to the wild-type as the ratio of the biomass increase of the mutant divided by that of the wild-type:   cfit = (biomass.loc[biomass['t'] == 24, 'TPI_KO'].iloc[0]/biomass.loc[biomass['t'] == 0, 'TPI_KO'].iloc[0])/(biomass.loc[biomass['t'] == 24, 'wt'].iloc[0]/biomass.loc[biomass['t'] == 0, 'wt'].iloc[0])\ncfit  0.39378816074777145",
            "title": "Run the simulation"
        },
        {
            "location": "/python-module/competition_assay/#simulating-serial-transfers",
            "text": "Using  COMETS  we can also simulate a serial tranfer competition between these two mutants. We will just modify the parameters, increasing the total simulation time and including batch transfers of 1% every 24h, but we will use the same  test_tube  layout as before.   serial_params = c.params()\nserial_params.set_param('maxCycles', 240*25) # simulate 4 serial transfers of 24h each\nserial_params.set_param('batchDilution', True)\nserial_params.set_param('dilFactor', 0.01)\nserial_params.set_param('dilTime', 24)  We run the simulation   serial_expt = c.comets(test_tube, serial_params)\nserial_expt.JAVA_CLASSPATH = comp_assay.JAVA_CLASSPATH\nserial_expt.run()  Running COMETS simulation ...\nDone!  Now plot the biomass of the two species during the experiment   biomass = serial_expt.total_biomass\nbiomass['transfer'] = biomass['cycle'] * comp_assay.parameters.all_params['timeStep']/24\n\nmyplot = biomass.drop(columns=['cycle']).plot(x = 'transfer')\nmyplot.set_ylabel(\"Biomass (gr.)\")",
            "title": "Simulating serial transfers"
        },
        {
            "location": "/python-module/chemostat/",
            "text": "Simulating a chemostat and crossfeeding with COMETS\n\n\nCOMETS provides the functionality to run simulations in a chemostat. Here, we use the python toolbox to generate a chemostat simulation in two ways. 1) by manually assigning all the \"parts,\" and 2) by using a helper function we've included.\n\n\nHere we are going to simulate a chemostat with lactose as the sole carbon resource and two strains of E. coli: one which is defiicient in the ability to uptake lactose, and one which is deficient in the ability to metabolize galactose. We will use the ijo1366 model provided as part of cobrapy. Let's first do the imports.\n\n\nimport cobra\nimport cobra.test # for the ijo1366 model\nimport sys\nsys.path.append(\"/home/jeremy/Dropbox/work_related/harcombe_lab/segre/COMETS-Python-Toolbox\")\nimport comets as c\n\n\n\n\nNow let's load the ijo1366 model, make a copy, and knockout the relevant reactions.\n\n\nNote that the first model had galE knocked out to prevent metabolism of galactose, which will cause galactose to be secreted during metabolism of lactose. The second model had a reaction knocked out instead of a gene, as lactose transport to the periplasm can be accomplished with multiple genes, and so it is simpler to juts knockout the reaction itself.\n\n\nE_no_galE = cobra.test.create_test_model(\"ecoli\") # this model will have galE KO'd\nE_no_LCTStex = E_no_galE.copy() # this model will have lactose uptake KO'd\nE_no_galE.genes.b0759.knock_out()\nE_no_LCTStex.reactions.LCTStex.knock_out()\n\n\n\n\nWe can test that the knockouts perform as expected by trying to grow them in media containing lactose and galactose. We do this in cobrapy.\n\n\nmedium = E_no_galE.medium\nmedium[\"EX_glc__D_e\"] = 0.\nmedium[\"EX_lcts_e\"] = 1.\nmedium[\"EX_gal_e\"] = 1.\nprint(medium)\nE_no_galE.medium = medium\nE_no_LCTStex.medium = medium\n# examine growth and uptake in the galE knockout shows galactose is excreted\nprint(\"\\n\\nE_no_galE uptakes lactose and excrete galactose: \")\nE_no_galE.summary()\n\n\n\n\n{'EX_ca2_e': 1000.0, 'EX_cbl1_e': 0.01, 'EX_cl_e': 1000.0, 'EX_co2_e': 1000.0, 'EX_cobalt2_e': 1000.0, 'EX_cu2_e': 1000.0, 'EX_fe2_e': 1000.0, 'EX_fe3_e': 1000.0, 'EX_glc__D_e': 0.0, 'EX_h_e': 1000.0, 'EX_h2o_e': 1000.0, 'EX_k_e': 1000.0, 'EX_mg2_e': 1000.0, 'EX_mn2_e': 1000.0, 'EX_mobd_e': 1000.0, 'EX_na1_e': 1000.0, 'EX_nh4_e': 1000.0, 'EX_ni2_e': 1000.0, 'EX_o2_e': 1000.0, 'EX_pi_e': 1000.0, 'EX_sel_e': 1000.0, 'EX_slnt_e': 1000.0, 'EX_so4_e': 1000.0, 'EX_tungs_e': 1000.0, 'EX_zn2_e': 1000.0, 'EX_lcts_e': 1.0, 'EX_gal_e': 1.0}\n\n\nE_no_galE uptakes lactose and excrete galactose:\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead tr th {\n        text-align: left;\n    }\n\n\n\n\n  \n\n    \n\n      \n\n      \nIN_FLUXES\n\n      \nOUT_FLUXES\n\n      \nOBJECTIVES\n\n    \n\n    \n\n      \n\n      \nID\n\n      \nFLUX\n\n      \nID\n\n      \nFLUX\n\n      \nID\n\n      \nFLUX\n\n    \n\n  \n\n  \n\n    \n\n      \n0\n\n      \no2_e\n\n      \n2.464303\n\n      \nh2o_e\n\n      \n4.131365\n\n      \nBIOMASS_Ec_iJO1366_core_53p95M\n\n      \n0.086479\n\n    \n\n    \n\n      \n1\n\n      \nlcts_e\n\n      \n1.000000\n\n      \nco2_e\n\n      \n2.450194\n\n      \nNaN\n\n      \nNaN\n\n    \n\n    \n\n      \n2\n\n      \nnh4_e\n\n      \n0.934040\n\n      \ngal_e\n\n      \n1.000000\n\n      \nNaN\n\n      \nNaN\n\n    \n\n    \n\n      \n3\n\n      \nfe2_e\n\n      \n0.795974\n\n      \nfe3_e\n\n      \n0.794585\n\n      \nNaN\n\n      \nNaN\n\n    \n\n    \n\n      \n4\n\n      \npi_e\n\n      \n0.083420\n\n      \nNaN\n\n      \nNaN\n\n      \nNaN\n\n      \nNaN\n\n    \n\n  \n\n\n\n\n\n\n\nprint(\"\\n\\nE_no_LCTStex uptakes galactose but not lactose: \")\nE_no_LCTStex.summary()\n\n\n\n\nE_no_LCTStex uptakes galactose but not lactose:\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead tr th {\n        text-align: left;\n    }\n\n\n\n\n  \n\n    \n\n      \n\n      \nIN_FLUXES\n\n      \nOUT_FLUXES\n\n      \nOBJECTIVES\n\n    \n\n    \n\n      \n\n      \nID\n\n      \nFLUX\n\n      \nID\n\n      \nFLUX\n\n      \nID\n\n      \nFLUX\n\n    \n\n  \n\n  \n\n    \n\n      \n0\n\n      \no2_e\n\n      \n2.310433\n\n      \nh2o_e\n\n      \n4.749252\n\n      \nBIOMASS_Ec_iJO1366_core_53p95M\n\n      \n0.085442\n\n    \n\n    \n\n      \n1\n\n      \ngal_e\n\n      \n1.000000\n\n      \nco2_e\n\n      \n2.492757\n\n      \nNaN\n\n      \nNaN\n\n    \n\n    \n\n      \n2\n\n      \nnh4_e\n\n      \n0.922840\n\n      \nh_e\n\n      \n0.785058\n\n      \nNaN\n\n      \nNaN\n\n    \n\n    \n\n      \n3\n\n      \npi_e\n\n      \n0.082420\n\n      \nNaN\n\n      \nNaN\n\n      \nNaN\n\n      \nNaN\n\n    \n\n  \n\n\n\n\n\n\n\nNow that we are satisfied we have made our models correctly, we can setup a COMES simulation. Let's intend that the medium above is the reservoir medium (except that we will remove galactose first), and that the input rate and output rate are 10% per hour. Here, let's set dilution rate parameter, the initial population size (in gDW), and generate the COMETS models. \n\n\nWhenever we make COMETS models from COBRA models, we almost always want to set the exchange lower bounds to -1000 so that COMETS can alter these based upon media concentrations.\n\n\nFinally, right now both models have the same ID, which will confuse COMETS, so we must give them unique IDs.\n\n\n# chemostat parameters\ndilution_rate = 0.1 # / hr\ninitial_pop = 1.e-3 # gDW\n\n# make COMETS models from the cobrapy models\nE_no_galE.id = \"galE_KO\"\nE_no_LCTStex.id = \"LCTStex_KO\"\n\ngalE_comets = c.model(E_no_galE)\ngalE_comets.initial_pop = [0,0,initial_pop] # x, y, gDW\ngalE_comets.reactions.loc[galE_comets.reactions.EXCH, \"LB\"] = -1000\n\nlcts_comets = c.model(E_no_LCTStex)\nlcts_comets.initial_pop = [0,0,initial_pop] # x, y, gDW\nlcts_comets.reactions.loc[lcts_comets.reactions.EXCH, \"LB\"] = -1000\n\n\n\n\nNow we are going to use the manual method for making a chemostat. Recall that cobrapy media are set using exchange reaction IDs, whereas COMETS media are set using metabolite ids. We can easily take care of this difference with a dictionary comprehension. Here we do that, then generate a layout, and add the media components to that layout.\n\n\n# setup layout by providing models\nlayout = c.layout([galE_comets, lcts_comets])\n\n# re-write media (while removing galactose) and add it to layout\ncomets_media = {key[3:]: value for key, value in medium.items() if key != \"EX_gal_e\"}\nfor key, value in comets_media.items():\n    layout.set_specific_metabolite(key, value)\n\n\n\n\nThe input of fresh media from the reservoir into the simulation is done using media_refresh. Metabolites with a media_refresh value are replenished at the specified amount per-hour. Since we are diluting at 0.1 per hour, we multiply the reservoir concentration by this rate.\n\n\nfor key, value in comets_media.items():\n    layout.set_specific_refresh(key, value * dilution_rate)\n\n\n\n\nThe rest of the chemostat--the outflow--is setup in the parameters using metaboliteDilutionRate and deathRate. These should be set equal to the desired dilution rate. Here we generate a parameters object and set these values.\n\n\nparams = c.params()\nparams.all_params[\"deathRate\"] = dilution_rate\nparams.all_params[\"metaboliteDilutionRate\"] = dilution_rate\n\n\n\n\nLet's also adjust a few other parameters.\n\n\nparams.all_params[\"timeStep\"] = 0.1 # hours\nparams.all_params[\"maxSpaceBiomass\"] = 10. # gDW\nparams.all_params[\"maxCycles\"] = 2000 # duration of simulation in time steps\n\n\n\n\nFinally, let's keep track of two key metabolites: lactose and galactose. We do this using the specificMedia log, and choosing the metabolites with a comma-separated string with no spaces.\n\n\nparams.all_params[\"writeSpecificMediaLog\"] = True\nparams.all_params[\"specificMediaLogRate\"] = 1 # time steps\nparams.all_params[\"specificMedia\"] = \"lcts_e,gal_e\" # metabolites to track\n\n\n\n\nNow the chemostat aspects are setup using the layout and the parameters. Therefore, we can generate a COMETS simulation, run it, and then examine the biomass and metabolites.\n\n\nsim = c.comets(layout, params)\nsim.run()\n\n\n\n\nwarning:  we cannot find required java class libraries at the expected locations\n    specifically, we cannot find the following libraries at these locations:\n\nlibrary common name      expected path\n___________________      _____________\ngurobi  /opt/gurobi900/linux64/gurobi.jar\njunit   /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/junit/junit-4.12.jar\nhamcrest    /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/junit/hamcrest-core-1.3.jar\njogl_all    /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/jogl-all.jar\ngluegen_rt  /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/gluegen-rt.jar\ngluegen /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/gluegen.jar\ngluegen_rt_natives  /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/gluegen-rt-natives-linux-amd64.jar\njogl_all_natives    /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/jogl-all-natives-linux-amd64.jar\njmatio  /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/JMatIO/lib/jamtio.jar\njmat    /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/JMatIO/JMatIO-041212/lib/jmatio.jar\nconcurrent  /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/colt/lib/concurrent.jar\ncolt    /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/colt/lib/colt.jar\nlang3   /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/commons-lang3-3.7/commons-lang3-3.7.jar\nmath3   /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/commons-math3-3.6.1/commons-math3-3.6.1.jar\nbin /Dropbox/work_related/harcombe_lab/segre/comets/bin/bin/comets_evo.jar\n\n  You have two options to fix this problem:\n1.  set each class path correctly by doing:\n    comets.set_classpath(libraryname, path)\n    e.g.   comets.set_classpath('hamcrest', '/home/chaco001/comets/junit/hamcrest-core-1.3.jar')\n\n    note that versions dont always have to exactly match, but you're on your own if they don't\n\n2.  fully define the classpath yourself by overwriting comets.JAVA_CLASSPATH\n       look at the current comets.JAVA_CLASSPATH to see how this should look.\n\nRunning COMETS simulation ...\n\n\n\n---------------------------------------------------------------------------\n\nFileNotFoundError                         Traceback (most recent call last)\n\n<ipython-input-11-7664732a7a8e> in <module>\n      9 sim.set_classpath(\"gurobi\",\"/opt/gurobi900/linux64/lib/gurobi.jar\")\n     10 sim.set_classpath(\"jdistlib\", \"/opt/jdistlib-0.4.5-bin.jar\")\n---> 11 sim.run()\n\n\n~/Dropbox/work_related/harcombe_lab/segre/COMETS-Python-Toolbox/comets.py in run(self, delete_files)\n   2249         # clean workspace\n   2250         if delete_files:\n-> 2251             os.remove(c_global)\n   2252             os.remove(c_package)\n   2253             os.remove(c_script)\n\n\nFileNotFoundError: [Errno 2] No such file or directory: '/home/jeremy/.current_global'\n\n\n\nNow let's plot the results. Note how we specify the axes, otherwise \"cycle\", \"x\", and \"y\" will be assumed to be state variables. \n\n\nWhat we see is that both species survive, because the LCTStex_KO cross-feeds galactose from the galE_KO, which uses the glucose piece of lactose. The metabolites, as is typical in a chemostat, are in very low concentrations once equilibrium is reached.\n\n\nsim.total_biomass.plot(x = \"cycle\", logy = True)\nsim.specific_media.plot(x = \"cycle\",y = [\"lcts_e\",\"gal_e\"])\n\n\n\n\n<matplotlib.axes._subplots.AxesSubplot at 0x7f3a947ff4e0>\n\n\n\n\n\n\n\nThe above code required setting chemostat parameters in multiple places. We offer this functionality so that researchers can create complex setups that may, for example, have different initial concentrations than reservoir concentrations, and different inflow rates than outflow rates. However, we expect most chemostat simulations will function like above, where a single dilution parameter dictates the behavior of the system. For this typical use-case, we have made a helper function which generates a layout and parameters objects with the correct setup.\n\n\nlayout, params = c.chemostat([galE_comets, lcts_comets], comets_media, dilution_rate)\n# we can still adjust the parameters as desired.\nparams.set_param(\"timeStep\", 0.1) # hours\nparams.set_param(\"maxSpaceBiomass\", 10.) # gDW\nparams.set_param(\"maxCycles\", 500) # duration of simulation in time steps\nparams.set_param(\"writeSpecificMediaLog\", True)\nparams.set_param(\"specificMediaLogRate\", 1) # time steps\nparams.set_param(\"specificMedia\", \"lcts_e,gal_e\") # metabolites to track\n# then we make the simulation object and run as before\nsim = c.comets(layout, params)\nsim.run()\nsim.total_biomass.plot(x = \"cycle\")\n\n\n\n\nwarning:  we cannot find required java class libraries at the expected locations\n    specifically, we cannot find the following libraries at these locations:\n\nlibrary common name      expected path\n___________________      _____________\ngurobi  /opt/gurobi900/linux64/gurobi.jar\njunit   /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/junit/junit-4.12.jar\nhamcrest    /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/junit/hamcrest-core-1.3.jar\njogl_all    /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/jogl-all.jar\ngluegen_rt  /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/gluegen-rt.jar\ngluegen /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/gluegen.jar\ngluegen_rt_natives  /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/gluegen-rt-natives-linux-amd64.jar\njogl_all_natives    /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/jogl/jogamp-all-platforms/jar/jogl-all-natives-linux-amd64.jar\njmatio  /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/JMatIO/lib/jamtio.jar\njmat    /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/JMatIO/JMatIO-041212/lib/jmatio.jar\nconcurrent  /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/colt/lib/concurrent.jar\ncolt    /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/colt/lib/colt.jar\nlang3   /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/commons-lang3-3.7/commons-lang3-3.7.jar\nmath3   /Dropbox/work_related/harcombe_lab/segre/comets/bin/lib/commons-math3-3.6.1/commons-math3-3.6.1.jar\nbin /Dropbox/work_related/harcombe_lab/segre/comets/bin/bin/comets_evo.jar\n\n  You have two options to fix this problem:\n1.  set each class path correctly by doing:\n    comets.set_classpath(libraryname, path)\n    e.g.   comets.set_classpath('hamcrest', '/home/chaco001/comets/junit/hamcrest-core-1.3.jar')\n\n    note that versions dont always have to exactly match, but you're on your own if they don't\n\n2.  fully define the classpath yourself by overwriting comets.JAVA_CLASSPATH\n       look at the current comets.JAVA_CLASSPATH to see how this should look.\n\nRunning COMETS simulation ...\nDone!\n\n\n\n\n\n<matplotlib.axes._subplots.AxesSubplot at 0x7f3a94644a90>",
            "title": "Continuous culture"
        },
        {
            "location": "/python-module/evolution/",
            "text": "Simulating evolution with COMETS\n\n\nCOMETS\n is able to perform simulations that include the appearance of mutants containing reaction deletions and additions. In this small example, we will perform a serial transfer experiment starting with a clonal \nEscherichia coli\n population, and simulate the random appearance of reaction deletion mutants. We will then visualize the dynamics of all genotypes in time.\n\n\nLoad the model\n\n\nWe start by importing the necessary libraries and loading the \nE. coli\n model. \n\n\nimport cometspy as c\nimport cobra.test\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# load model \nwt = cobra.test.create_test_model(\"ecoli\")\n\n\n\n\nUsing license file /home/djordje/gurobi.lic\nAcademic license - for non-commercial use only\n\n\n\nRemove the bounds for all exchange reactions in the model to allow them to be controlled dynamically by \nCOMETS\n \n\n\n# Remove bounds from exchange reactions\nfor i in wt.reactions:\n    if 'EX_' in i.id:\n        i.lower_bound =-1000.0\n\n\n\n\nSet up the layout\n\n\nWe create a well mixed environment with a glucose minimal media. Here, we use the custom \nadd_typical_trace_metabolites\n method to add trace metabolites (ions, metals etc) in unlimited amounts (\nstatic\n flag).\n\n\n# generate layout\ntest_tube = c.layout()\ntest_tube.set_specific_metabolite('glc__D_e', 0.0001)\ntest_tube.add_typical_trace_metabolites(amount=1000)\n\n# add model\nwt = c.model(wt)\nwt.initial_pop = [0, 0, 1e-7]\ntest_tube.add_model(wt)\n\n\n\n\nbuilding empty layout model\nmodels will need to be added with layout.add_model()\nWarning: The added metabolite (glc__D_e) is notable to be taken up by any of the current models\n\n\n\nSet up simulation parameters\n\n\nCreate a params object, and modify the needed parameters. The simulation in this example simulation consists of 10 days of experiment, with a 1:2 transfer every 3h. The mutation rate will be \n10^{-7}\n10^{-7}\n deletion events per reaction and generation. The \ncellSize\n parameter sets the amount of biomass that appears when a mutant occurs (i.e., one mutant cell appears).\n\n\n# .. load parameters and layout from file\nevo_params = c.params()\n\nevo_paramsset_param('timeStep', 0.1)             # hours\n\nevo_paramsset_param('maxCycles', 2400)            # simulate 10 serial transfers of 24h each (timeStep = 0.1)\nevo_paramsset_param('batchDilution', True)\nevo_paramsset_param('dilFactor', 0.5)            # Dilution to apply\nevo_paramsset_param('dilTime', 3)                # hours\n\nevo_paramsset_param('evolution', True)\nevo_paramsset_param('mutRate', 1e-8)             # \nevo_paramsset_param('cellSize', 1e-10)           # cellSize should always be larger than maxSpaceBiomass\nevo_paramsset_param('minSpaceBiomass', 1e-11)    # make sure it is smaller than cell size!\n\n\nevo_paramsset_param('BiomassLogRate', 1)\n\n\n\n\nRun the simulation\n\n\nWe now create the COMETS object using the above layout and parameters, and run the simulation. \n\n\n# create comets object from the loaded parameters and layout \nevo_simulation = c.comets(test_tube, evo_params)\nevo_simulation.JAVA_CLASSPATH = '/home/djordje/Dropbox/COMETS_RUN/lib/jmatio.jar:/home/djordje/Dropbox/COMETS_RUN/lib/jdistlib-0.4.5-bin.jar:/home/djordje/Dropbox/COMETS_RUN/lib/commons-math3-3.6.1.jar:/home/djordje/Dropbox/COMETS_RUN/lib/commons-lang3-3.9.jar:/home/djordje/Dropbox/COMETS_RUN/lib/colt.jar:/home/djordje/Dropbox/COMETS_RUN/lib/concurrent.jar:/home/djordje/Dropbox/COMETS_RUN/bin/comets_2.9.3.jar:/opt/gurobi901/linux64/lib/gurobi.jar'\n\n# run comets simulation\nevo_simulation.run()\n\n\n\n\nWarning: java class libraries cannot be found\nThese are the expected locations for dependencies:\nDependency           expected path\n__________           _____________\njunit           /home/djordje/Dropbox/COMETS_RUN/lib/junit/junit-4.12.jar\nhamcrest            /home/djordje/Dropbox/COMETS_RUN/lib/junit/hamcrest-core-1.3.jar\njogl_all            /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/jogl-all.jar\ngluegen_rt          /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/gluegen-rt.jar\ngluegen         /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/gluegen.jar\ngluegen_rt_natives          /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/gluegen-rt-natives-linux-amd64.jar\njogl_all_natives            /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/jogl-all-natives-linux-amd64.jar\njmatio          /home/djordje/Dropbox/COMETS_RUN/lib/JMatIO/lib/jamtio.jar\njmat            /home/djordje/Dropbox/COMETS_RUN/lib/JMatIO/JMatIO-041212/lib/jmatio.jar\nconcurrent          /home/djordje/Dropbox/COMETS_RUN/lib/colt/lib/concurrent.jar\ncolt            /home/djordje/Dropbox/COMETS_RUN/lib/colt/lib/colt.jar\nlang3           /home/djordje/Dropbox/COMETS_RUN/lib/commons-lang3-3.7/commons-lang3-3.7.jar\nmath3           /home/djordje/Dropbox/COMETS_RUN/lib/commons-math3-3.6.1/commons-math3-3.6.1.jar\n\n  You have two options to fix this problem:\n1.  set each class path correctly by doing:\n    comets.set_classpath(libraryname, path)\n    e.g.   comets.set_classpath('hamcrest', '/home/chaco001/comets/junit/hamcrest-core-1.3.jar')\n\n    note that versions dont always have to exactly match, but you're on your own if they don't\n\n2.  fully define the classpath yourself by overwriting comets.JAVA_CLASSPATH\n       look at the current comets.JAVA_CLASSPATH to see how this should look.\n\nRunning COMETS simulation ...\nDone!\n\n\n\nVisualize the results\n\n\nWe can visualize the population dynamics of all species over time (color coded) using standard Python plotting tools.\n\n\nfig, ax = plt.subplots(figsize=(15, 5))\n\nfor key, grp in evo_simulation.biomass.groupby(['species']):\n    ax = grp.plot(ax=ax, kind='line', x='cycle', y='biomass')\nax.get_legend().remove()\nplt.yscale('log')\nplt.ylabel(\"Biomass (gr.)\")\n\n\n\n\nText(0,0.5,'Biomass (gr.)')\n\n\n\n\n\nIn order to analyze the results, it is also helpful to visualize the genotypes data frame, which contains all the mutants that ever appeared during the simulation. The data frame contains three columns: The ancestor, the mutation, and the name of the resulting genotype, which is assigned as a random hash.\n\n\nevo_simulation.genotypes",
            "title": "Simulating evolutionary processes"
        },
        {
            "location": "/python-module/evolution/#simulating-evolution-with-comets",
            "text": "COMETS  is able to perform simulations that include the appearance of mutants containing reaction deletions and additions. In this small example, we will perform a serial transfer experiment starting with a clonal  Escherichia coli  population, and simulate the random appearance of reaction deletion mutants. We will then visualize the dynamics of all genotypes in time.",
            "title": "Simulating evolution with COMETS"
        },
        {
            "location": "/python-module/evolution/#load-the-model",
            "text": "We start by importing the necessary libraries and loading the  E. coli  model.   import cometspy as c\nimport cobra.test\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# load model \nwt = cobra.test.create_test_model(\"ecoli\")  Using license file /home/djordje/gurobi.lic\nAcademic license - for non-commercial use only  Remove the bounds for all exchange reactions in the model to allow them to be controlled dynamically by  COMETS    # Remove bounds from exchange reactions\nfor i in wt.reactions:\n    if 'EX_' in i.id:\n        i.lower_bound =-1000.0",
            "title": "Load the model"
        },
        {
            "location": "/python-module/evolution/#set-up-the-layout",
            "text": "We create a well mixed environment with a glucose minimal media. Here, we use the custom  add_typical_trace_metabolites  method to add trace metabolites (ions, metals etc) in unlimited amounts ( static  flag).  # generate layout\ntest_tube = c.layout()\ntest_tube.set_specific_metabolite('glc__D_e', 0.0001)\ntest_tube.add_typical_trace_metabolites(amount=1000)\n\n# add model\nwt = c.model(wt)\nwt.initial_pop = [0, 0, 1e-7]\ntest_tube.add_model(wt)  building empty layout model\nmodels will need to be added with layout.add_model()\nWarning: The added metabolite (glc__D_e) is notable to be taken up by any of the current models",
            "title": "Set up the layout"
        },
        {
            "location": "/python-module/evolution/#set-up-simulation-parameters",
            "text": "Create a params object, and modify the needed parameters. The simulation in this example simulation consists of 10 days of experiment, with a 1:2 transfer every 3h. The mutation rate will be  10^{-7} 10^{-7}  deletion events per reaction and generation. The  cellSize  parameter sets the amount of biomass that appears when a mutant occurs (i.e., one mutant cell appears).  # .. load parameters and layout from file\nevo_params = c.params()\n\nevo_paramsset_param('timeStep', 0.1)             # hours\n\nevo_paramsset_param('maxCycles', 2400)            # simulate 10 serial transfers of 24h each (timeStep = 0.1)\nevo_paramsset_param('batchDilution', True)\nevo_paramsset_param('dilFactor', 0.5)            # Dilution to apply\nevo_paramsset_param('dilTime', 3)                # hours\n\nevo_paramsset_param('evolution', True)\nevo_paramsset_param('mutRate', 1e-8)             # \nevo_paramsset_param('cellSize', 1e-10)           # cellSize should always be larger than maxSpaceBiomass\nevo_paramsset_param('minSpaceBiomass', 1e-11)    # make sure it is smaller than cell size!\n\n\nevo_paramsset_param('BiomassLogRate', 1)",
            "title": "Set up simulation parameters"
        },
        {
            "location": "/python-module/evolution/#run-the-simulation",
            "text": "We now create the COMETS object using the above layout and parameters, and run the simulation.   # create comets object from the loaded parameters and layout \nevo_simulation = c.comets(test_tube, evo_params)\nevo_simulation.JAVA_CLASSPATH = '/home/djordje/Dropbox/COMETS_RUN/lib/jmatio.jar:/home/djordje/Dropbox/COMETS_RUN/lib/jdistlib-0.4.5-bin.jar:/home/djordje/Dropbox/COMETS_RUN/lib/commons-math3-3.6.1.jar:/home/djordje/Dropbox/COMETS_RUN/lib/commons-lang3-3.9.jar:/home/djordje/Dropbox/COMETS_RUN/lib/colt.jar:/home/djordje/Dropbox/COMETS_RUN/lib/concurrent.jar:/home/djordje/Dropbox/COMETS_RUN/bin/comets_2.9.3.jar:/opt/gurobi901/linux64/lib/gurobi.jar'\n\n# run comets simulation\nevo_simulation.run()  Warning: java class libraries cannot be found\nThese are the expected locations for dependencies:\nDependency           expected path\n__________           _____________\njunit           /home/djordje/Dropbox/COMETS_RUN/lib/junit/junit-4.12.jar\nhamcrest            /home/djordje/Dropbox/COMETS_RUN/lib/junit/hamcrest-core-1.3.jar\njogl_all            /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/jogl-all.jar\ngluegen_rt          /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/gluegen-rt.jar\ngluegen         /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/gluegen.jar\ngluegen_rt_natives          /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/gluegen-rt-natives-linux-amd64.jar\njogl_all_natives            /home/djordje/Dropbox/COMETS_RUN/lib/jogl/jogamp-all-platforms/jar/jogl-all-natives-linux-amd64.jar\njmatio          /home/djordje/Dropbox/COMETS_RUN/lib/JMatIO/lib/jamtio.jar\njmat            /home/djordje/Dropbox/COMETS_RUN/lib/JMatIO/JMatIO-041212/lib/jmatio.jar\nconcurrent          /home/djordje/Dropbox/COMETS_RUN/lib/colt/lib/concurrent.jar\ncolt            /home/djordje/Dropbox/COMETS_RUN/lib/colt/lib/colt.jar\nlang3           /home/djordje/Dropbox/COMETS_RUN/lib/commons-lang3-3.7/commons-lang3-3.7.jar\nmath3           /home/djordje/Dropbox/COMETS_RUN/lib/commons-math3-3.6.1/commons-math3-3.6.1.jar\n\n  You have two options to fix this problem:\n1.  set each class path correctly by doing:\n    comets.set_classpath(libraryname, path)\n    e.g.   comets.set_classpath('hamcrest', '/home/chaco001/comets/junit/hamcrest-core-1.3.jar')\n\n    note that versions dont always have to exactly match, but you're on your own if they don't\n\n2.  fully define the classpath yourself by overwriting comets.JAVA_CLASSPATH\n       look at the current comets.JAVA_CLASSPATH to see how this should look.\n\nRunning COMETS simulation ...\nDone!",
            "title": "Run the simulation"
        },
        {
            "location": "/python-module/evolution/#visualize-the-results",
            "text": "We can visualize the population dynamics of all species over time (color coded) using standard Python plotting tools.  fig, ax = plt.subplots(figsize=(15, 5))\n\nfor key, grp in evo_simulation.biomass.groupby(['species']):\n    ax = grp.plot(ax=ax, kind='line', x='cycle', y='biomass')\nax.get_legend().remove()\nplt.yscale('log')\nplt.ylabel(\"Biomass (gr.)\")  Text(0,0.5,'Biomass (gr.)')   In order to analyze the results, it is also helpful to visualize the genotypes data frame, which contains all the mutants that ever appeared during the simulation. The data frame contains three columns: The ancestor, the mutation, and the name of the resulting genotype, which is assigned as a random hash.  evo_simulation.genotypes",
            "title": "Visualize the results"
        },
        {
            "location": "/python-module/citrate/",
            "text": "Studying the evolution citrate utilization in the Long Term Evolution Experiment.\n\n\nWe here demonstrate the use of COMETS to study the effect of specific mutations on population dynamics in the context of experimental evolution. To do this, we will use one of the most well known evolution experiments, the \nE. coli\n Long Term evolution experiment [cite]. \n\n\nAfter ~33,000 generations, a large population expansion was observed in one of the replicates (Ara-3) of the \nE. coli\n long term evolution experiment (Blount et al 2008). This population expansion is associated with two key mutations that together enable the evolution of strong aerobic citrate use (Cit++ phenotype). The first mutation (occuring roughly 31,000 generations) caused the aerobic expression of the citT transporter, producing a weak citrate growth phenotype (Cit+, Blount et al 2012). A subsequent mutation (occuring roughly 33,000 generations in) caused high-level, constitutive expression of dctA, a proton-driven dicarboxylic acid transporter (Quandt et al 2014). Because these two mutations introduce known reactions into the e.coli metabolic network we can simulate them using COMETS.\n\n\nThis example simulation uses the same models, paramaters and reaction knockouts outlined in (Bajic et al 2018).\n\n\nFirst, create the layout and simulate the DM25 medium. \n\n\nimport cometspy as c\nimport matplotlib as plt\nimport cobra.test\nimport cobra\nimport pandas as pd\nimport numpy as np\n\nlayout = c.layout()\n\n#Set up media to be DM25\nlayout.add_typical_trace_metabolites()\nlayout.set_specific_metabolite('glc__D_e', 0.000139)\nlayout.set_specific_metabolite('cit_e', 0.0017)\n\n\n\n\nbuilding empty layout model\nmodels will need to be added with layout.add_model()\nWarning: The added metabolite (glc__D_e) is notable to be taken up by any of the current models\nWarning: The added metabolite (cit_e) is notable to be taken up by any of the current models\n\n\n\nNow load the model and build the mutants. To show the compatibility with the COBRApy toolbox, we will load the model and perform the mutations using COBRA, and then pass these models as input to build COMETS models. \n\n\nUnlike the LTEE ancestral strain REL606 (and \nE. coli\n in general), which possess the necessary genes for citrate utilization but do not express them in aerobic conditions, iJO1366 is able utilize both citrate and succinate as these reactions are unbounded by default. Thus, the ancestral phenotype can be recreated by knocking out three reactions CITt7pp (citT), SUCCt2_2pp (dctA) and SUCCt2_3pp (dcuA or dcuB). \n\n\n# Load the E. coli iJO1366 model \nmod  = cobra.test.create_test_model('ecoli')\n\n# Set exchange reaction lower bounds to -1000 to allow them being controlled by COMETS \nfor i in mod.reactions:\n    if 'EX_' in i.id:\n        i.lower_bound =-1000.0\n\n#now create the mutants \nmod.reactions.SUCCt2_3pp.upper_bound=0.0\nCitTdctA = mod.copy()\nmod.reactions.SUCCt2_2pp.upper_bound =0.0\nCitT = mod.copy()\nmod.reactions.CITt7pp.upper_bound =0.0\nWT = mod.copy()\nWT.id= 'Ancestor'\nCitT.id = 'Cit+'\nCitTdctA.id = 'Cit++'\n\n# Generate comets models and set their initial population size\np = c.model(WT)\np.initial_pop = [0, 0, 3.9e-11] # We'll introduce genotypes 100 cells at a time to avoid the risk of them going extinct through drift\np2 = c.model(CitT)\np2.initial_pop = [0, 0, 0] # not present at start\np3 = c.model(CitTdctA)\np3.initial_pop = [0, 0, 0] # not present at start\n\n# Add the models to the simulation \nlayout.add_model(p)\nlayout.add_model(p2)\nlayout.add_model(p3)\n\n\n\n\nUsing license file /home/djordje/gurobi.lic\nAcademic license - for non-commercial use only\nRead LP format model from file /tmp/tmpj1e0_y3y.lp\nReading time = 0.03 seconds\n: 1805 rows, 5166 columns, 20366 nonzeros\nRead LP format model from file /tmp/tmpikjkpd7n.lp\nReading time = 0.02 seconds\n: 1805 rows, 5166 columns, 20366 nonzeros\nRead LP format model from file /tmp/tmpabof91tv.lp\nReading time = 0.03 seconds\n: 1805 rows, 5166 columns, 20366 nonzeros\n\n\n\nSet the parameters for the simulation. We use 1 hr as the COMETS timestep to speed up the simulation. Shortening this to the more commonly used 0.1 hr does not substantially affect the final result, but it does significantly increase the time it takes this simulation to run.\n\n\n### Setting paramaters for the simulation ###\nb_params = c.params()\nb_params.all_params['timeStep'] = 1.0 \nb_params.all_params['deathRate'] = 0.01\nb_params.all_params['batchDilution'] =True\nb_params.all_params['dilTime'] =24\nb_params.all_params['dilFactor'] =100\nb_params.all_params['cellSize']= 3.9e-13 #Size of a single cell\nb_params.all_params['minSpaceBiomass'] = 3.8e-13\n\n\n\n\nPerform the simulations. We will divide our simulation in three actual COMETS runs. We will start the simulation at generation 25000 and run for around 6000 generations. At roughly generation 31,000, we introduce the CitT genotype and run for around 2000 Generations. Finally, at roughly Generation 33,000 we introduce the CitTdctA Genotype and run for a final 6000 generations. For each run, we will input the final biomass composition of the previous run. biomass of each store the biomass data in a separate dataframe that we will then join together for analysis. \n\n\n\n\n\n\n\nRunning COMETS simulation ...\nDone!\n\n\n\ncycles_per_day = 24.0/b_params.all_params['timeStep']\n\n# We'll start at Generation 25,000.  and run for around 6000 generations\nbatch_test = c.comets(layout, b_params)\nbatch_test.parameters.all_params['maxCycles'] = int(900*cycles_per_day)\nbatch_test.run()\nphase_1 = pd.DataFrame({'Ancestor' : batch_test.total_biomass.Ancestor/(3.9e-13),\n                        'CitT' : batch_test.total_biomass['Cit+']/(3.9e-13),\n                        'CitTdctA' : batch_test.total_biomass['Cit++']/(3.9e-13),\n                        'Generations' : 6.67*(batch_test.total_biomass.cycle+1)/cycles_per_day + 25000})\n\n# At roughly Generation 31,000 we introduce the CitT genotype and run for around 2000 Generations\nbatch_test.layout.models[0].initial_pop = [0, 0, float(batch_test.total_biomass.Ancestor.tail(1))]\nbatch_test.layout.models[1].initial_pop = [0, 0, 3.9e-11]\nbatch_test.layout.build_initial_pop()\nbatch_test.parameters.set_param('maxCycles', int(300*cycles_per_day))\nbatch_test.run()\nphase_2 = pd.DataFrame({'Ancestor' : batch_test.total_biomass.Ancestor/(3.9e-13),\n                        'CitT' : batch_test.total_biomass['Cit+']/(3.9e-13),\n                        'CitTdctA' : batch_test.total_biomass['Cit++']/(3.9e-13),\n                        'Generations' : 6.67*(batch_test.total_biomass.cycle)/cycles_per_day + max(phase_1.Generations)})\n\n# At roughly Generation 33,000 we introduce the CitTdctA Genotype and run for a final 6000 generationr \nbatch_test.layout.models[0].initial_pop = [0, 0, float(batch_test.total_biomass.Ancestor.tail(1))]\nbatch_test.layout.models[1].initial_pop = [0, 0, float(batch_test.total_biomass['Cit+'].tail(1))]\nbatch_test.layout.models[2].initial_pop = [0, 0, 3.9e-11]\nbatch_test.layout.build_initial_pop()\nbatch_test.parameters.set_param('maxCycles', int(900*cycles_per_day))\nbatch_test.run()\nphase_3 = pd.DataFrame({'Ancestor' : batch_test.total_biomass.Ancestor/(3.9e-13),\n                        'CitT' : batch_test.total_biomass['Cit+']/(3.9e-13),\n                        'CitTdctA' : batch_test.total_biomass['Cit++']/(3.9e-13),\n                        'Generations' : 6.67*(batch_test.total_biomass.cycle)/cycles_per_day + max(phase_2.Generations) })\n\n\n\n\nRunning COMETS simulation ...\nDone!\n\nRunning COMETS simulation ...\nDone!\n\n\n\nGroup all the results from the three runs together and plot the stationary phase population size through time. \n\n\n#Remove the final timepoint from each phase\nphase_1.drop(phase_1.tail(1).index, inplace=True)\nphase_2.drop(phase_2.tail(1).index, inplace=True)\nphase_3.drop(phase_3.tail(1).index, inplace=True)\n\nfinal_df = pd.concat([phase_1,phase_2,phase_3])\nfinal_df.reindex()\nfinal_df = final_df[np.round((final_df.Generations - 25000) % 6.67,3) == 6.67]\n\n\n\n\nfig = final_df.plot(x='Generations')\nfig.set_yscale(\"log\")",
            "title": "Citrate use in the LTEE"
        },
        {
            "location": "/python-module/citrate/#studying-the-evolution-citrate-utilization-in-the-long-term-evolution-experiment",
            "text": "We here demonstrate the use of COMETS to study the effect of specific mutations on population dynamics in the context of experimental evolution. To do this, we will use one of the most well known evolution experiments, the  E. coli  Long Term evolution experiment [cite].   After ~33,000 generations, a large population expansion was observed in one of the replicates (Ara-3) of the  E. coli  long term evolution experiment (Blount et al 2008). This population expansion is associated with two key mutations that together enable the evolution of strong aerobic citrate use (Cit++ phenotype). The first mutation (occuring roughly 31,000 generations) caused the aerobic expression of the citT transporter, producing a weak citrate growth phenotype (Cit+, Blount et al 2012). A subsequent mutation (occuring roughly 33,000 generations in) caused high-level, constitutive expression of dctA, a proton-driven dicarboxylic acid transporter (Quandt et al 2014). Because these two mutations introduce known reactions into the e.coli metabolic network we can simulate them using COMETS.  This example simulation uses the same models, paramaters and reaction knockouts outlined in (Bajic et al 2018).  First, create the layout and simulate the DM25 medium.   import cometspy as c\nimport matplotlib as plt\nimport cobra.test\nimport cobra\nimport pandas as pd\nimport numpy as np\n\nlayout = c.layout()\n\n#Set up media to be DM25\nlayout.add_typical_trace_metabolites()\nlayout.set_specific_metabolite('glc__D_e', 0.000139)\nlayout.set_specific_metabolite('cit_e', 0.0017)  building empty layout model\nmodels will need to be added with layout.add_model()\nWarning: The added metabolite (glc__D_e) is notable to be taken up by any of the current models\nWarning: The added metabolite (cit_e) is notable to be taken up by any of the current models  Now load the model and build the mutants. To show the compatibility with the COBRApy toolbox, we will load the model and perform the mutations using COBRA, and then pass these models as input to build COMETS models.   Unlike the LTEE ancestral strain REL606 (and  E. coli  in general), which possess the necessary genes for citrate utilization but do not express them in aerobic conditions, iJO1366 is able utilize both citrate and succinate as these reactions are unbounded by default. Thus, the ancestral phenotype can be recreated by knocking out three reactions CITt7pp (citT), SUCCt2_2pp (dctA) and SUCCt2_3pp (dcuA or dcuB).   # Load the E. coli iJO1366 model \nmod  = cobra.test.create_test_model('ecoli')\n\n# Set exchange reaction lower bounds to -1000 to allow them being controlled by COMETS \nfor i in mod.reactions:\n    if 'EX_' in i.id:\n        i.lower_bound =-1000.0\n\n#now create the mutants \nmod.reactions.SUCCt2_3pp.upper_bound=0.0\nCitTdctA = mod.copy()\nmod.reactions.SUCCt2_2pp.upper_bound =0.0\nCitT = mod.copy()\nmod.reactions.CITt7pp.upper_bound =0.0\nWT = mod.copy()\nWT.id= 'Ancestor'\nCitT.id = 'Cit+'\nCitTdctA.id = 'Cit++'\n\n# Generate comets models and set their initial population size\np = c.model(WT)\np.initial_pop = [0, 0, 3.9e-11] # We'll introduce genotypes 100 cells at a time to avoid the risk of them going extinct through drift\np2 = c.model(CitT)\np2.initial_pop = [0, 0, 0] # not present at start\np3 = c.model(CitTdctA)\np3.initial_pop = [0, 0, 0] # not present at start\n\n# Add the models to the simulation \nlayout.add_model(p)\nlayout.add_model(p2)\nlayout.add_model(p3)  Using license file /home/djordje/gurobi.lic\nAcademic license - for non-commercial use only\nRead LP format model from file /tmp/tmpj1e0_y3y.lp\nReading time = 0.03 seconds\n: 1805 rows, 5166 columns, 20366 nonzeros\nRead LP format model from file /tmp/tmpikjkpd7n.lp\nReading time = 0.02 seconds\n: 1805 rows, 5166 columns, 20366 nonzeros\nRead LP format model from file /tmp/tmpabof91tv.lp\nReading time = 0.03 seconds\n: 1805 rows, 5166 columns, 20366 nonzeros  Set the parameters for the simulation. We use 1 hr as the COMETS timestep to speed up the simulation. Shortening this to the more commonly used 0.1 hr does not substantially affect the final result, but it does significantly increase the time it takes this simulation to run.  ### Setting paramaters for the simulation ###\nb_params = c.params()\nb_params.all_params['timeStep'] = 1.0 \nb_params.all_params['deathRate'] = 0.01\nb_params.all_params['batchDilution'] =True\nb_params.all_params['dilTime'] =24\nb_params.all_params['dilFactor'] =100\nb_params.all_params['cellSize']= 3.9e-13 #Size of a single cell\nb_params.all_params['minSpaceBiomass'] = 3.8e-13  Perform the simulations. We will divide our simulation in three actual COMETS runs. We will start the simulation at generation 25000 and run for around 6000 generations. At roughly generation 31,000, we introduce the CitT genotype and run for around 2000 Generations. Finally, at roughly Generation 33,000 we introduce the CitTdctA Genotype and run for a final 6000 generations. For each run, we will input the final biomass composition of the previous run. biomass of each store the biomass data in a separate dataframe that we will then join together for analysis.     Running COMETS simulation ...\nDone!  cycles_per_day = 24.0/b_params.all_params['timeStep']\n\n# We'll start at Generation 25,000.  and run for around 6000 generations\nbatch_test = c.comets(layout, b_params)\nbatch_test.parameters.all_params['maxCycles'] = int(900*cycles_per_day)\nbatch_test.run()\nphase_1 = pd.DataFrame({'Ancestor' : batch_test.total_biomass.Ancestor/(3.9e-13),\n                        'CitT' : batch_test.total_biomass['Cit+']/(3.9e-13),\n                        'CitTdctA' : batch_test.total_biomass['Cit++']/(3.9e-13),\n                        'Generations' : 6.67*(batch_test.total_biomass.cycle+1)/cycles_per_day + 25000})\n\n# At roughly Generation 31,000 we introduce the CitT genotype and run for around 2000 Generations\nbatch_test.layout.models[0].initial_pop = [0, 0, float(batch_test.total_biomass.Ancestor.tail(1))]\nbatch_test.layout.models[1].initial_pop = [0, 0, 3.9e-11]\nbatch_test.layout.build_initial_pop()\nbatch_test.parameters.set_param('maxCycles', int(300*cycles_per_day))\nbatch_test.run()\nphase_2 = pd.DataFrame({'Ancestor' : batch_test.total_biomass.Ancestor/(3.9e-13),\n                        'CitT' : batch_test.total_biomass['Cit+']/(3.9e-13),\n                        'CitTdctA' : batch_test.total_biomass['Cit++']/(3.9e-13),\n                        'Generations' : 6.67*(batch_test.total_biomass.cycle)/cycles_per_day + max(phase_1.Generations)})\n\n# At roughly Generation 33,000 we introduce the CitTdctA Genotype and run for a final 6000 generationr \nbatch_test.layout.models[0].initial_pop = [0, 0, float(batch_test.total_biomass.Ancestor.tail(1))]\nbatch_test.layout.models[1].initial_pop = [0, 0, float(batch_test.total_biomass['Cit+'].tail(1))]\nbatch_test.layout.models[2].initial_pop = [0, 0, 3.9e-11]\nbatch_test.layout.build_initial_pop()\nbatch_test.parameters.set_param('maxCycles', int(900*cycles_per_day))\nbatch_test.run()\nphase_3 = pd.DataFrame({'Ancestor' : batch_test.total_biomass.Ancestor/(3.9e-13),\n                        'CitT' : batch_test.total_biomass['Cit+']/(3.9e-13),\n                        'CitTdctA' : batch_test.total_biomass['Cit++']/(3.9e-13),\n                        'Generations' : 6.67*(batch_test.total_biomass.cycle)/cycles_per_day + max(phase_2.Generations) })  Running COMETS simulation ...\nDone!\n\nRunning COMETS simulation ...\nDone!  Group all the results from the three runs together and plot the stationary phase population size through time.   #Remove the final timepoint from each phase\nphase_1.drop(phase_1.tail(1).index, inplace=True)\nphase_2.drop(phase_2.tail(1).index, inplace=True)\nphase_3.drop(phase_3.tail(1).index, inplace=True)\n\nfinal_df = pd.concat([phase_1,phase_2,phase_3])\nfinal_df.reindex()\nfinal_df = final_df[np.round((final_df.Generations - 25000) % 6.67,3) == 6.67]  fig = final_df.plot(x='Generations')\nfig.set_yscale(\"log\")",
            "title": "Studying the evolution citrate utilization in the Long Term Evolution Experiment."
        },
        {
            "location": "/python-module/soil/",
            "text": "Soil-air interface.\n\n\nUsing the functionality of COMETS, one can design simulations which go beyond in silico corollaries of lab experiments to make predictions for environments mimicking natural ecosystems, which is a necessary step for understanding natural ecology from first principles. In this example, we consider a simulation of a soil environment. We use source-and-sink functions to model how a root provides organic acids to the environment while removing ammonia (Huang et al 2014 Botany). While we restrict the root functionality to a source/sink, one could use functionality demonstrated above, for example extracellular enzymes, to generate feedback loops between microbe-produced metabolites and root exudation. We use fixed metabolite concentrations to mimic the largely unchanging air interface above a root, which generates an oxygen gradient. Additionally, since soil is characterized by strong spatial structure with many impenetrable barriers that localized interactions (Nunan 2017), we place \u201crock\u201d barriers throughout the simulation area. A more complex simulation could use varying diffusion constants for metabolites, as described in a previous protocol (Virtual Petri Dish). Similarly, we use standard diffusion of biomass, but this could be changed to use pushing force or non-linear diffusion for a potentially increased realism.\n\n\nimport cobra\nimport cobra.test # for the ijo1366 model\nimport sys\nimport copy\nimport numpy as np\nimport cometspy as c\n\n\n\n\nFor the strain models, we use three well-curated soil bacteria, Pseudomonas putida (model iJN747), Bacillus subtilis (model iYO844), and Methanosarcina barkeri (model iAF629), which are available in the BIGG database (King et al 2016).\n\n\nAlso, upon loading, the biomass functions of these models had positive lower bounds, which we then set to zero. \n\n\nmodel_dir = \"/home/jeremy/Dropbox/work_related/harcombe_lab/segre/soil_root_eg\" # model location\niJN = cobra.io.read_sbml_model(model_dir + '/iJN746.xml')\niJN.reactions.get_by_id('BIOMASS_KT_TEMP').lower_bound = 0\niJN.reactions.get_by_id('BIOMASS_KT_TEMP').upper_bound = 1000\n\niAF = cobra.io.read_sbml_model(model_dir + '/iAF692.xml')\niAF.reactions.get_by_id('BIOMASS_Mb_30').lower_bound = 0\niAF.reactions.get_by_id('BIOMASS_Mb_30').upper_bound = 1000\n\niYO = cobra.io.read_sbml_model(model_dir + '/iYO844.xml')\niYO.reactions.get_by_id('BIOMASS_BS_10').lower_bound = 0\niYO.reactions.get_by_id('BIOMASS_BS_10').upper_bound = 1000\n\n\n\n\nNext, we convert these into COMETS models. We also use some helper functions to a) ensure the COMETS model does not think \"sink\" reactions are exchange reactions (as they are unbalanced in Cobra models, and therefore appear similar to exchanges), and b) open all exchange reaction bounds, to make sure that COMETS is in control of the media composition.\n\n\niJN_comets = c.model(iJN)\niJN_comets.ensure_sinks_are_not_exchanges()\niJN_comets.open_exchanges()\n\niAF_comets = c.model(iAF)\niAF_comets.ensure_sinks_are_not_exchanges()\niAF_comets.open_exchanges()\n\niYO_comets = c.model(iYO)\niYO_comets.ensure_sinks_are_not_exchanges()\niYO_comets.open_exchanges()\n\n\n\n\nOur simulated world will be a 100x100 box lattice. The left-hand side, where x = 0, will be the root. The top, where y = 0, will be the air. Therefore, the biomass and the rocks will be distributed everywhere else. To ensure that we do not attempt to place biomass where rocks are placed, we first determine the rock locations. Specifically, we will create 70 rocks which are impervious to any biomass or metabolite. These rocks will have an average size of 15 boxes. To pick these locations, we use the helper function COMETS.grow_rocks:\n\n\ngrid_size = 50 # 100\nn_rocks = 70 # 70\nrock_locs = c.grow_rocks(n = n_rocks, xrange = [1,grid_size],yrange = [1,grid_size],mean_size = int(grid_size / 5))\n\n\n\n\nEach species will have biomass seeded at 60 different locations, with no overlap. We will use the helper function pick_random_locations for this, which is useful as it can take in a previously-generated list of tuples of x-y locations as \u201cforbidden\u201d locations, such as the rock locations.\n\n\nFirst we make a copy of the rock_locs so we don\\'t accidentally alter it, and call this copy forbidden_locs.\n\n\nimport copy\nforbidden_locs = copy.deepcopy(rock_locs)\n\n\n\n\nNext we pick the random locations for each species, adding these locations to the forbidden locs as we go so as to prevent overlap.\n\n\nfounders_per_species = 20 # 60\niJN_locs = c.pick_random_locations(n = founders_per_species, \n                                   xrange = [1,grid_size], yrange = [1,grid_size], \n                                   forbidden_locs = forbidden_locs)\nforbidden_locs.extend(iJN_locs)\niYO_locs = c.pick_random_locations(founders_per_species, [1,grid_size],[1,grid_size], forbidden_locs)\nforbidden_locs.extend(iYO_locs)\niAF_locs = c.pick_random_locations(founders_per_species, [1,grid_size],[1,grid_size], forbidden_locs)\nforbidden_locs.extend(iAF_locs)\n\n\n\n\nIf we wish to take a look at what locations were chosen, we can easily make an image with matplotlib:\n\n\nfrom matplotlib import pyplot as plt\ninitial_image = np.zeros((grid_size,grid_size,3))\nfor rock in rock_locs:\n    initial_image[rock[1]-1,rock[0]-1,0:3] = 0.5 \nfor loc in iJN_locs:\n    initial_image[loc[1]-1,loc[0]-1,0] = 1\nfor loc in iYO_locs:\n    initial_image[loc[1]-1,loc[0]-1,1] = 1\nfor loc in iAF_locs:\n    initial_image[loc[1]-1,loc[0]-1,2] = 1\nplt.imshow(initial_image)\n\n\n\n\n\n\nThings look good so we continue by making the layout and setting the dimensions. Then, we add the rock barriers to the layout.\n\n\nlayout = c.layout()\nlayout.grid = [grid_size,grid_size]\nlayout.add_barriers(rock_locs)\n\n\n\n\nbuilding empty layout model\nmodels will need to be added with layout.add_model()\n\n\n\nWe set the initial population for each species by using a python list comprehension. Note that locations are properties of the model.\n\n\nAfter setting initial populations, the models are finished, so we add them to the layout.\n\n\niJN_comets.initial_pop = [[loc[0],loc[1],1e-8] for loc in iJN_locs]\niYO_comets.initial_pop = [[loc[0],loc[1],1e-8] for loc in iYO_locs]\niAF_comets.initial_pop = [[loc[0],loc[1],1e-8] for loc in iAF_locs]\n\nlayout.add_model(iJN_comets)\nlayout.add_model(iYO_comets)\nlayout.add_model(iAF_comets)\n\n\n\n\nWe want some metabolites available initially. These include all the typical trace nutrients needed, so we start with the helper function.\n\n\nAfter that, however, we want oxygen to mostly diffuse from the air, so we set that value lower. We also add a few other trace metabolites homogeneously throughout the environment that were not added with the helper function.\n\n\nlayout.add_typical_trace_metabolites()\nlayout.set_specific_metabolite('o2_e',0.00001)\nlayout.set_specific_metabolite('hco3_e',1000)\nlayout.set_specific_metabolite('co2_e',1000)\nlayout.set_specific_metabolite('h2_e',1000)\nlayout.set_specific_metabolite('so3_e',1000)\nlayout.set_specific_metabolite('nh4_e',0.000001)\n\nlayout.set_specific_metabolite('glc__D_e',0.0000001)\nlayout.set_specific_metabolite('meoh_e',0.00000001)\nlayout.set_specific_metabolite('cys__L_e',0.0000001)\nlayout.set_specific_metabolite('4abz_e',0.0000001)\nlayout.set_specific_metabolite('nac_e',0.00000001)\n\n\n\n\nTo make the air layer, we set static media, which keep that metabolite at a fixed value.  We also set a static level of zero oxygen at the \"bottom,\" to mimic continuous downwards diffusion.\n\n\nIn a similar fashion, we set a static sink of ammonium where the \u201croot\u201d is.\n\n\n# set static media of O2 and CO2 at the top and bottom-- the \"air\" and continuous loss of O2 downwards\nfor x in range(grid_size):\n    layout.set_specific_static_at_location('o2_e', (x,0), .0001) # top\n    layout.set_specific_static_at_location('o2_e', (x,grid_size-1), 0.) # bottom\n    layout.set_specific_static_at_location('co2_e', (x,0), .0001)\n\nfor x in range(grid_size):\n    layout.set_specific_static_at_location('nh4_e', (0,x), 0.0)\n\n\n\n\nIn contrast to ammonia, which we assume is always entirely consumed by the root, we assume the root drips organic acids and methanol into the environment at fixed rate, so we use a refresh function.\n\n\nfor x in range(grid_size):\n    layout.set_specific_refresh_at_location('cit_e', (0,x), .000001)\n    layout.set_specific_refresh_at_location('meoh_e', (0,x), .000001)\n    layout.set_specific_refresh_at_location('succ_e', (0,x), .000001)\n\n\n\n\nWe are now done prepping the models and the layout. Next we setup the simulation parameters. Note the positive death rate.\n\n\nparams = c.params()\nparams.set_param('timeStep', 0.1)\nparams.set_param('maxCycles', 5000)\nparams.set_param('maxSpaceBiomass', 10)\nparams.set_param('deathRate', 0.0001) # die at rate of 1/10000 per hour\nparams.set_param('writeBiomassLog', True)\nparams.set_param('BiomassLogRate', 500)\nparams.set_param('writeMediaLog', True)\nparams.set_param('MediaLogRate', 500)\nparams.set_param(\"writeFluxLog\", True)\nparams.set_param(\"FluxLogRate\", 500)\nparams.set_param('numRunThreads', 3)\nparams.set_param('defaultKm', 0.000001)\n\n\n\n\nsim = c.comets(layout, params)\nsim.run(False)\n\n\n\n\nRunning COMETS simulation ...\nDone!\n\n\n\nprint(sim.run_output)\n\n\n\n\nNow we make a simulation object and run it.  This can take awhile.\n\n\nim = sim.get_biomass_image('iJN746', params.all_params['maxCycles'])\nim2 = sim.get_biomass_image('iYO844',params.all_params['maxCycles'])\nim3 = sim.get_biomass_image('iAF692',params.all_params['maxCycles'])\n\nfinal = np.zeros((grid_size,grid_size,3))\nfinal[:,:,0] = im / np.max(im)\nfinal[:,:,1] = im2 / np.max(im2)\nfinal[:,:,2] = im3 / np.max(im3)\nfor rock in rock_locs:\n    final[rock[1]-1,rock[0]-1,0:3] = 0.5 \nfrom matplotlib import pyplot as plt\nimport matplotlib.colors, matplotlib.cm\nmy_cmap = matplotlib.cm.get_cmap(\"copper\")\nmy_cmap.set_bad((0,0,0))\n\nplt.imshow(final)\n\n\n\n\n<matplotlib.image.AxesImage at 0x7f9665e74208>\n\n\n\n\n\nsim.biomass_backup = sim.biomass\n\n\n\n\nsim.biomass = sim.biomass.groupby([\"cycle\",\"x\",\"y\"]).sum().reset_index()\n\n\n\n\nsim.biomass = sim.biomass_backup\n\n\n\n\nsim.biomass\n\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n\n\n\n\n  \n\n    \n\n      \n\n      \ncycle\n\n      \nx\n\n      \ny\n\n      \nspecies\n\n      \nbiomass\n\n    \n\n  \n\n  \n\n    \n\n      \n0\n\n      \n0\n\n      \n4\n\n      \n22\n\n      \niJN746\n\n      \n1.000000e-08\n\n    \n\n    \n\n      \n1\n\n      \n0\n\n      \n4\n\n      \n22\n\n      \niYO844\n\n      \n0.000000e+00\n\n    \n\n    \n\n      \n2\n\n      \n0\n\n      \n4\n\n      \n22\n\n      \niAF692\n\n      \n0.000000e+00\n\n    \n\n    \n\n      \n3\n\n      \n0\n\n      \n10\n\n      \n5\n\n      \niJN746\n\n      \n1.000000e-08\n\n    \n\n    \n\n      \n4\n\n      \n0\n\n      \n10\n\n      \n5\n\n      \niYO844\n\n      \n0.000000e+00\n\n    \n\n    \n\n      \n...\n\n      \n...\n\n      \n...\n\n      \n...\n\n      \n...\n\n      \n...\n\n    \n\n    \n\n      \n2668\n\n      \n10\n\n      \n29\n\n      \n28\n\n      \niYO844\n\n      \n0.000000e+00\n\n    \n\n    \n\n      \n2669\n\n      \n10\n\n      \n29\n\n      \n28\n\n      \niAF692\n\n      \n0.000000e+00\n\n    \n\n    \n\n      \n2670\n\n      \n10\n\n      \n29\n\n      \n29\n\n      \niJN746\n\n      \n0.000000e+00\n\n    \n\n    \n\n      \n2671\n\n      \n10\n\n      \n29\n\n      \n29\n\n      \niYO844\n\n      \n0.000000e+00\n\n    \n\n    \n\n      \n2672\n\n      \n10\n\n      \n29\n\n      \n29\n\n      \niAF692\n\n      \n0.000000e+00\n\n    \n\n  \n\n\n\n\n2673 rows \u00d7 5 columns\n\n\n\n\n\nim2",
            "title": "Soil-air interface"
        },
        {
            "location": "/colony/",
            "text": "Simulating the growth of a colony\n\n\nWe demonstrate here a simple \nCOMETS\n simulation with space, the growth of an \nE. coli\n colony using a 2D spatial lattice.\n\n\nimport comets as c\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.cm, matplotlib.colors\nimport copy\n\npd.options.display.max_rows = 10\n\n\n\n\nAs usual, we first create a parameters object using the \nparams\n class.\n\n\nmy_params = c.params()\nmy_params.all_params['maxCycles'] = 300\nmy_params.all_params['writeBiomassLog'] = True\n\n\n\n\nWe next load a layout for our simulation \n\n\nmy_layout = c.layout('test_colony/colony_layout')\nmy_layout.initial_pop\n\n\n\n\n[[10.0, 10.0, 1e-07]]\n\n\n\n# create comets object from the loaded parameters and layout \nmy_comets = c.comets(my_layout, my_params)\n\n# run comets simulation\nmy_comets.run()\n\n\n\n\nRunning COMETS simulation ...\nDone!\n\n\n\nWe can print the stderr and stdout, which are stored in the \nrun_errors\n and \nrun_output\n fields:\n\n\nprint(my_comets.run_errors)\n\n\n\n\nSTDERR empty.\n\n\n\nAnd here is how our incipient \nE. coli\n colony looks like: \n\n\nimport numpy as np\n\nbiomass_END = np.zeros((my_layout.grid[0], my_layout.grid[1]))\n\naux = my_comets.biomass.loc[my_comets.biomass['Cycle'] == 300]\nfor index, row in aux.iterrows():\n    biomass_END[row['x'], row['y']] = row['biomass']\n\nmy_cmap = copy.copy(matplotlib.cm.get_cmap('copper')) # copy the default cmap\nmy_cmap.set_bad((0,0,0))\n\nplt.imshow(biomass_END, interpolation='nearest', \n           norm=matplotlib.colors.LogNorm(), cmap=my_cmap)",
            "title": "Example"
        },
        {
            "location": "/colony/#simulating-the-growth-of-a-colony",
            "text": "We demonstrate here a simple  COMETS  simulation with space, the growth of an  E. coli  colony using a 2D spatial lattice.  import comets as c\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.cm, matplotlib.colors\nimport copy\n\npd.options.display.max_rows = 10  As usual, we first create a parameters object using the  params  class.  my_params = c.params()\nmy_params.all_params['maxCycles'] = 300\nmy_params.all_params['writeBiomassLog'] = True  We next load a layout for our simulation   my_layout = c.layout('test_colony/colony_layout')\nmy_layout.initial_pop  [[10.0, 10.0, 1e-07]]  # create comets object from the loaded parameters and layout \nmy_comets = c.comets(my_layout, my_params)\n\n# run comets simulation\nmy_comets.run()  Running COMETS simulation ...\nDone!  We can print the stderr and stdout, which are stored in the  run_errors  and  run_output  fields:  print(my_comets.run_errors)  STDERR empty.  And here is how our incipient  E. coli  colony looks like:   import numpy as np\n\nbiomass_END = np.zeros((my_layout.grid[0], my_layout.grid[1]))\n\naux = my_comets.biomass.loc[my_comets.biomass['Cycle'] == 300]\nfor index, row in aux.iterrows():\n    biomass_END[row['x'], row['y']] = row['biomass']\n\nmy_cmap = copy.copy(matplotlib.cm.get_cmap('copper')) # copy the default cmap\nmy_cmap.set_bad((0,0,0))\n\nplt.imshow(biomass_END, interpolation='nearest', \n           norm=matplotlib.colors.LogNorm(), cmap=my_cmap)",
            "title": "Simulating the growth of a colony"
        }
    ]
}